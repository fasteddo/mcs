// license:BSD-3-Clause
// copyright-holders:Edward Fast

using System;
using System.Collections.Generic;

using device_type = mame.emu.detail.device_type_impl_base;
using int32_t = System.Int32;
using offs_t = System.UInt32;
using osd_ticks_t = System.UInt64;
using stream_sample_t = System.Int32;
using u32 = System.UInt32;
using uint8_t = System.Byte;
using uint32_t = System.UInt32;


namespace mame
{
    /*************************************
     *
     *  The node numbers themselves
     *
     *************************************/

    //define NODE0_DEF(_x) NODE_ ## 0 ## _x = (0x40000000 + (_x) * DISCRETE_MAX_OUTPUTS), \
    //    NODE_ ## 0 ## _x ## _00 = NODE_ ## 0 ## _x, NODE_ ## 0 ## _x ## _01, NODE_ ## 0 ## _x ## _02, NODE_ ## 0 ## _x ## _03, \
    //    NODE_ ## 0 ## _x ## _04, NODE_ ## 0 ## _x ## _05, NODE_ ## 0 ## _x ## _06, NODE_ ## 0 ## _x ## _07
    //define NODE_DEF(_x) NODE_ ## _x = (0x40000000 + (_x) * DISCRETE_MAX_OUTPUTS), \
    //    NODE_ ## _x ## _00 = NODE_ ## _x, NODE_ ## _x ## _01, NODE_ ## _x ## _02, NODE_ ## _x ## _03, \
    //    NODE_ ## _x ## _04, NODE_ ## _x ## _05, NODE_ ## _x ## _06, NODE_ ## _x ## _07

    public enum NODE
    {
        //NODE0_DEF(_x)
        //NODE_ ## 0 ## _x = (0x40000000 + (_x) * DISCRETE_MAX_OUTPUTS), \
        //NODE_ ## 0 ## _x ## _00 = NODE_ ## 0 ## _x,
        //NODE_ ## 0 ## _x ## _01, 
        //NODE_ ## 0 ## _x ## _02, 
        //NODE_ ## 0 ## _x ## _03, \
        //NODE_ ## 0 ## _x ## _04, 
        //NODE_ ## 0 ## _x ## _05, 
        //NODE_ ## 0 ## _x ## _06, 
        //NODE_ ## 0 ## _x ## _07

        NODE_00 = 0x40000000 + 0 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_00_00 = NODE_00, NODE_00_01, NODE_00_02, NODE_00_03, NODE_00_04, NODE_00_05, NODE_00_06, NODE_00_07, 
        NODE_01 = 0x40000000 + 1 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_01_00 = NODE_01, NODE_01_01, NODE_01_02, NODE_01_03, NODE_01_04, NODE_01_05, NODE_01_06, NODE_01_07, 
        NODE_02 = 0x40000000 + 2 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_02_00 = NODE_02, NODE_02_01, NODE_02_02, NODE_02_03, NODE_02_04, NODE_02_05, NODE_02_06, NODE_02_07, 
        NODE_03 = 0x40000000 + 3 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_03_00 = NODE_03, NODE_03_01, NODE_03_02, NODE_03_03, NODE_03_04, NODE_03_05, NODE_03_06, NODE_03_07, 
        NODE_04 = 0x40000000 + 4 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_04_00 = NODE_04, NODE_04_01, NODE_04_02, NODE_04_03, NODE_04_04, NODE_04_05, NODE_04_06, NODE_04_07, 
        NODE_05 = 0x40000000 + 5 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_05_00 = NODE_05, NODE_05_01, NODE_05_02, NODE_05_03, NODE_05_04, NODE_05_05, NODE_05_06, NODE_05_07, 
        NODE_06 = 0x40000000 + 6 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_06_00 = NODE_06, NODE_06_01, NODE_06_02, NODE_06_03, NODE_06_04, NODE_06_05, NODE_06_06, NODE_06_07, 
        NODE_07 = 0x40000000 + 7 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_07_00 = NODE_07, NODE_07_01, NODE_07_02, NODE_07_03, NODE_07_04, NODE_07_05, NODE_07_06, NODE_07_07, 
        NODE_08 = 0x40000000 + 8 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_08_00 = NODE_08, NODE_08_01, NODE_08_02, NODE_08_03, NODE_08_04, NODE_08_05, NODE_08_06, NODE_08_07, 
        NODE_09 = 0x40000000 + 9 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_09_00 = NODE_09, NODE_09_01, NODE_09_02, NODE_09_03, NODE_09_04, NODE_09_05, NODE_09_06, NODE_09_07, 

        NODE_10 = 0x40000000 + 10 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_10_00 = NODE_10, NODE_10_01, NODE_10_02, NODE_10_03, NODE_10_04, NODE_10_05, NODE_10_06, NODE_10_07, 
        NODE_11 = 0x40000000 + 11 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_11_00 = NODE_11, NODE_11_01, NODE_11_02, NODE_11_03, NODE_11_04, NODE_11_05, NODE_11_06, NODE_11_07, 
        NODE_12 = 0x40000000 + 12 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_12_00 = NODE_12, NODE_12_01, NODE_12_02, NODE_12_03, NODE_12_04, NODE_12_05, NODE_12_06, NODE_12_07, 
        NODE_13 = 0x40000000 + 13 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_13_00 = NODE_13, NODE_13_01, NODE_13_02, NODE_13_03, NODE_13_04, NODE_13_05, NODE_13_06, NODE_13_07, 
        NODE_14 = 0x40000000 + 14 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_14_00 = NODE_14, NODE_14_01, NODE_14_02, NODE_14_03, NODE_14_04, NODE_14_05, NODE_14_06, NODE_14_07, 
        NODE_15 = 0x40000000 + 15 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_15_00 = NODE_15, NODE_15_01, NODE_15_02, NODE_15_03, NODE_15_04, NODE_15_05, NODE_15_06, NODE_15_07, 
        NODE_16 = 0x40000000 + 16 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_16_00 = NODE_16, NODE_16_01, NODE_16_02, NODE_16_03, NODE_16_04, NODE_16_05, NODE_16_06, NODE_16_07, 
        NODE_17 = 0x40000000 + 17 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_17_00 = NODE_17, NODE_17_01, NODE_17_02, NODE_17_03, NODE_17_04, NODE_17_05, NODE_17_06, NODE_17_07, 
        NODE_18 = 0x40000000 + 18 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_18_00 = NODE_18, NODE_18_01, NODE_18_02, NODE_18_03, NODE_18_04, NODE_18_05, NODE_18_06, NODE_18_07, 
        NODE_19 = 0x40000000 + 19 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_19_00 = NODE_19, NODE_19_01, NODE_19_02, NODE_19_03, NODE_19_04, NODE_19_05, NODE_19_06, NODE_19_07, 

        NODE_20 = 0x40000000 + 20 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_20_00 = NODE_20, NODE_20_01, NODE_20_02, NODE_20_03, NODE_20_04, NODE_20_05, NODE_20_06, NODE_20_07, 
        NODE_21 = 0x40000000 + 21 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_21_00 = NODE_21, NODE_21_01, NODE_21_02, NODE_21_03, NODE_21_04, NODE_21_05, NODE_21_06, NODE_21_07, 
        NODE_22 = 0x40000000 + 22 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_22_00 = NODE_22, NODE_22_01, NODE_22_02, NODE_22_03, NODE_22_04, NODE_22_05, NODE_22_06, NODE_22_07, 
        NODE_23 = 0x40000000 + 23 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_23_00 = NODE_23, NODE_23_01, NODE_23_02, NODE_23_03, NODE_23_04, NODE_23_05, NODE_23_06, NODE_23_07, 
        NODE_24 = 0x40000000 + 24 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_24_00 = NODE_24, NODE_24_01, NODE_24_02, NODE_24_03, NODE_24_04, NODE_24_05, NODE_24_06, NODE_24_07, 
        NODE_25 = 0x40000000 + 25 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_25_00 = NODE_25, NODE_25_01, NODE_25_02, NODE_25_03, NODE_25_04, NODE_25_05, NODE_25_06, NODE_25_07, 
        NODE_26 = 0x40000000 + 26 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_26_00 = NODE_26, NODE_26_01, NODE_26_02, NODE_26_03, NODE_26_04, NODE_26_05, NODE_26_06, NODE_26_07, 
        NODE_27 = 0x40000000 + 27 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_27_00 = NODE_27, NODE_27_01, NODE_27_02, NODE_27_03, NODE_27_04, NODE_27_05, NODE_27_06, NODE_27_07, 
        NODE_28 = 0x40000000 + 28 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_28_00 = NODE_28, NODE_28_01, NODE_28_02, NODE_28_03, NODE_28_04, NODE_28_05, NODE_28_06, NODE_28_07, 
        NODE_29 = 0x40000000 + 29 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_29_00 = NODE_29, NODE_29_01, NODE_29_02, NODE_29_03, NODE_29_04, NODE_29_05, NODE_29_06, NODE_29_07, 

        NODE_30 = 0x40000000 + 30 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_30_00 = NODE_30, NODE_30_01, NODE_30_02, NODE_30_03, NODE_30_04, NODE_30_05, NODE_30_06, NODE_30_07, 
        NODE_31 = 0x40000000 + 31 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_31_00 = NODE_31, NODE_31_01, NODE_31_02, NODE_31_03, NODE_31_04, NODE_31_05, NODE_31_06, NODE_31_07, 
        NODE_32 = 0x40000000 + 32 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_32_00 = NODE_32, NODE_32_01, NODE_32_02, NODE_32_03, NODE_32_04, NODE_32_05, NODE_32_06, NODE_32_07, 
        NODE_33 = 0x40000000 + 33 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_33_00 = NODE_33, NODE_33_01, NODE_33_02, NODE_33_03, NODE_33_04, NODE_33_05, NODE_33_06, NODE_33_07, 
        NODE_34 = 0x40000000 + 34 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_34_00 = NODE_34, NODE_34_01, NODE_34_02, NODE_34_03, NODE_34_04, NODE_34_05, NODE_34_06, NODE_34_07, 
        NODE_35 = 0x40000000 + 35 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_35_00 = NODE_35, NODE_35_01, NODE_35_02, NODE_35_03, NODE_35_04, NODE_35_05, NODE_35_06, NODE_35_07, 
        NODE_36 = 0x40000000 + 36 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_36_00 = NODE_36, NODE_36_01, NODE_36_02, NODE_36_03, NODE_36_04, NODE_36_05, NODE_36_06, NODE_36_07, 
        NODE_37 = 0x40000000 + 37 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_37_00 = NODE_37, NODE_37_01, NODE_37_02, NODE_37_03, NODE_37_04, NODE_37_05, NODE_37_06, NODE_37_07, 
        NODE_38 = 0x40000000 + 38 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_38_00 = NODE_38, NODE_38_01, NODE_38_02, NODE_38_03, NODE_38_04, NODE_38_05, NODE_38_06, NODE_38_07, 
        NODE_39 = 0x40000000 + 39 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_39_00 = NODE_39, NODE_39_01, NODE_39_02, NODE_39_03, NODE_39_04, NODE_39_05, NODE_39_06, NODE_39_07, 

        NODE_40 = 0x40000000 + 40 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_40_00 = NODE_40, NODE_40_01, NODE_40_02, NODE_40_03, NODE_40_04, NODE_40_05, NODE_40_06, NODE_40_07, 
        NODE_41 = 0x40000000 + 41 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_41_00 = NODE_41, NODE_41_01, NODE_41_02, NODE_41_03, NODE_41_04, NODE_41_05, NODE_41_06, NODE_41_07, 
        NODE_42 = 0x40000000 + 42 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_42_00 = NODE_42, NODE_42_01, NODE_42_02, NODE_42_03, NODE_42_04, NODE_42_05, NODE_42_06, NODE_42_07, 
        NODE_43 = 0x40000000 + 43 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_43_00 = NODE_43, NODE_43_01, NODE_43_02, NODE_43_03, NODE_43_04, NODE_43_05, NODE_43_06, NODE_43_07, 
        NODE_44 = 0x40000000 + 44 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_44_00 = NODE_44, NODE_44_01, NODE_44_02, NODE_44_03, NODE_44_04, NODE_44_05, NODE_44_06, NODE_44_07, 
        NODE_45 = 0x40000000 + 45 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_45_00 = NODE_45, NODE_45_01, NODE_45_02, NODE_45_03, NODE_45_04, NODE_45_05, NODE_45_06, NODE_45_07, 
        NODE_46 = 0x40000000 + 46 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_46_00 = NODE_46, NODE_46_01, NODE_46_02, NODE_46_03, NODE_46_04, NODE_46_05, NODE_46_06, NODE_46_07, 
        NODE_47 = 0x40000000 + 47 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_47_00 = NODE_47, NODE_47_01, NODE_47_02, NODE_47_03, NODE_47_04, NODE_47_05, NODE_47_06, NODE_47_07, 
        NODE_48 = 0x40000000 + 48 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_48_00 = NODE_48, NODE_48_01, NODE_48_02, NODE_48_03, NODE_48_04, NODE_48_05, NODE_48_06, NODE_48_07, 
        NODE_49 = 0x40000000 + 49 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_49_00 = NODE_49, NODE_49_01, NODE_49_02, NODE_49_03, NODE_49_04, NODE_49_05, NODE_49_06, NODE_49_07, 

        NODE_50 = 0x40000000 + 50 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_50_00 = NODE_50, NODE_50_01, NODE_50_02, NODE_50_03, NODE_50_04, NODE_50_05, NODE_50_06, NODE_50_07, 
        NODE_51 = 0x40000000 + 51 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_51_00 = NODE_51, NODE_51_01, NODE_51_02, NODE_51_03, NODE_51_04, NODE_51_05, NODE_51_06, NODE_51_07, 
        NODE_52 = 0x40000000 + 52 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_52_00 = NODE_52, NODE_52_01, NODE_52_02, NODE_52_03, NODE_52_04, NODE_52_05, NODE_52_06, NODE_52_07, 
        NODE_53 = 0x40000000 + 53 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_53_00 = NODE_53, NODE_53_01, NODE_53_02, NODE_53_03, NODE_53_04, NODE_53_05, NODE_53_06, NODE_53_07, 
        NODE_54 = 0x40000000 + 54 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_54_00 = NODE_54, NODE_54_01, NODE_54_02, NODE_54_03, NODE_54_04, NODE_54_05, NODE_54_06, NODE_54_07, 
        NODE_55 = 0x40000000 + 55 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_55_00 = NODE_55, NODE_55_01, NODE_55_02, NODE_55_03, NODE_55_04, NODE_55_05, NODE_55_06, NODE_55_07, 
        NODE_56 = 0x40000000 + 56 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_56_00 = NODE_56, NODE_56_01, NODE_56_02, NODE_56_03, NODE_56_04, NODE_56_05, NODE_56_06, NODE_56_07, 
        NODE_57 = 0x40000000 + 57 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_57_00 = NODE_57, NODE_57_01, NODE_57_02, NODE_57_03, NODE_57_04, NODE_57_05, NODE_57_06, NODE_57_07, 
        NODE_58 = 0x40000000 + 58 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_58_00 = NODE_58, NODE_58_01, NODE_58_02, NODE_58_03, NODE_58_04, NODE_58_05, NODE_58_06, NODE_58_07, 
        NODE_59 = 0x40000000 + 59 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_59_00 = NODE_59, NODE_59_01, NODE_59_02, NODE_59_03, NODE_59_04, NODE_59_05, NODE_59_06, NODE_59_07, 

        NODE_60 = 0x40000000 + 60 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_60_00 = NODE_60, NODE_60_01, NODE_60_02, NODE_60_03, NODE_60_04, NODE_60_05, NODE_60_06, NODE_60_07, 
        NODE_61 = 0x40000000 + 61 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_61_00 = NODE_61, NODE_61_01, NODE_61_02, NODE_61_03, NODE_61_04, NODE_61_05, NODE_61_06, NODE_61_07, 
        NODE_62 = 0x40000000 + 62 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_62_00 = NODE_62, NODE_62_01, NODE_62_02, NODE_62_03, NODE_62_04, NODE_62_05, NODE_62_06, NODE_62_07, 
        NODE_63 = 0x40000000 + 63 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_63_00 = NODE_63, NODE_63_01, NODE_63_02, NODE_63_03, NODE_63_04, NODE_63_05, NODE_63_06, NODE_63_07, 
        NODE_64 = 0x40000000 + 64 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_64_00 = NODE_64, NODE_64_01, NODE_64_02, NODE_64_03, NODE_64_04, NODE_64_05, NODE_64_06, NODE_64_07, 
        NODE_65 = 0x40000000 + 65 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_65_00 = NODE_65, NODE_65_01, NODE_65_02, NODE_65_03, NODE_65_04, NODE_65_05, NODE_65_06, NODE_65_07, 
        NODE_66 = 0x40000000 + 66 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_66_00 = NODE_66, NODE_66_01, NODE_66_02, NODE_66_03, NODE_66_04, NODE_66_05, NODE_66_06, NODE_66_07, 
        NODE_67 = 0x40000000 + 67 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_67_00 = NODE_67, NODE_67_01, NODE_67_02, NODE_67_03, NODE_67_04, NODE_67_05, NODE_67_06, NODE_67_07, 
        NODE_68 = 0x40000000 + 68 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_68_00 = NODE_68, NODE_68_01, NODE_68_02, NODE_68_03, NODE_68_04, NODE_68_05, NODE_68_06, NODE_68_07, 
        NODE_69 = 0x40000000 + 69 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_69_00 = NODE_69, NODE_69_01, NODE_69_02, NODE_69_03, NODE_69_04, NODE_69_05, NODE_69_06, NODE_69_07, 

        NODE_70 = 0x40000000 + 70 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_70_00 = NODE_70, NODE_70_01, NODE_70_02, NODE_70_03, NODE_70_04, NODE_70_05, NODE_70_06, NODE_70_07, 
        NODE_71 = 0x40000000 + 71 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_71_00 = NODE_71, NODE_71_01, NODE_71_02, NODE_71_03, NODE_71_04, NODE_71_05, NODE_71_06, NODE_71_07, 
        NODE_72 = 0x40000000 + 72 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_72_00 = NODE_72, NODE_72_01, NODE_72_02, NODE_72_03, NODE_72_04, NODE_72_05, NODE_72_06, NODE_72_07, 
        NODE_73 = 0x40000000 + 73 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_73_00 = NODE_73, NODE_73_01, NODE_73_02, NODE_73_03, NODE_73_04, NODE_73_05, NODE_73_06, NODE_73_07, 
        NODE_74 = 0x40000000 + 74 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_74_00 = NODE_74, NODE_74_01, NODE_74_02, NODE_74_03, NODE_74_04, NODE_74_05, NODE_74_06, NODE_74_07, 
        NODE_75 = 0x40000000 + 75 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_75_00 = NODE_75, NODE_75_01, NODE_75_02, NODE_75_03, NODE_75_04, NODE_75_05, NODE_75_06, NODE_75_07, 
        NODE_76 = 0x40000000 + 76 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_76_00 = NODE_76, NODE_76_01, NODE_76_02, NODE_76_03, NODE_76_04, NODE_76_05, NODE_76_06, NODE_76_07, 
        NODE_77 = 0x40000000 + 77 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_77_00 = NODE_77, NODE_77_01, NODE_77_02, NODE_77_03, NODE_77_04, NODE_77_05, NODE_77_06, NODE_77_07, 
        NODE_78 = 0x40000000 + 78 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_78_00 = NODE_78, NODE_78_01, NODE_78_02, NODE_78_03, NODE_78_04, NODE_78_05, NODE_78_06, NODE_78_07, 
        NODE_79 = 0x40000000 + 79 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_79_00 = NODE_79, NODE_79_01, NODE_79_02, NODE_79_03, NODE_79_04, NODE_79_05, NODE_79_06, NODE_79_07, 

        NODE_80 = 0x40000000 + 80 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_80_00 = NODE_80, NODE_80_01, NODE_80_02, NODE_80_03, NODE_80_04, NODE_80_05, NODE_80_06, NODE_80_07, 
        NODE_81 = 0x40000000 + 81 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_81_00 = NODE_81, NODE_81_01, NODE_81_02, NODE_81_03, NODE_81_04, NODE_81_05, NODE_81_06, NODE_81_07, 
        NODE_82 = 0x40000000 + 82 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_82_00 = NODE_82, NODE_82_01, NODE_82_02, NODE_82_03, NODE_82_04, NODE_82_05, NODE_82_06, NODE_82_07, 
        NODE_83 = 0x40000000 + 83 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_83_00 = NODE_83, NODE_83_01, NODE_83_02, NODE_83_03, NODE_83_04, NODE_83_05, NODE_83_06, NODE_83_07, 
        NODE_84 = 0x40000000 + 84 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_84_00 = NODE_84, NODE_84_01, NODE_84_02, NODE_84_03, NODE_84_04, NODE_84_05, NODE_84_06, NODE_84_07, 
        NODE_85 = 0x40000000 + 85 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_85_00 = NODE_85, NODE_85_01, NODE_85_02, NODE_85_03, NODE_85_04, NODE_85_05, NODE_85_06, NODE_85_07, 
        NODE_86 = 0x40000000 + 86 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_86_00 = NODE_86, NODE_86_01, NODE_86_02, NODE_86_03, NODE_86_04, NODE_86_05, NODE_86_06, NODE_86_07, 
        NODE_87 = 0x40000000 + 87 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_87_00 = NODE_87, NODE_87_01, NODE_87_02, NODE_87_03, NODE_87_04, NODE_87_05, NODE_87_06, NODE_87_07, 
        NODE_88 = 0x40000000 + 88 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_88_00 = NODE_88, NODE_88_01, NODE_88_02, NODE_88_03, NODE_88_04, NODE_88_05, NODE_88_06, NODE_88_07, 
        NODE_89 = 0x40000000 + 89 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_89_00 = NODE_89, NODE_89_01, NODE_89_02, NODE_89_03, NODE_89_04, NODE_89_05, NODE_89_06, NODE_89_07, 

        NODE_90 = 0x40000000 + 90 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_90_00 = NODE_90, NODE_90_01, NODE_90_02, NODE_90_03, NODE_90_04, NODE_90_05, NODE_90_06, NODE_90_07, 
        NODE_91 = 0x40000000 + 91 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_91_00 = NODE_91, NODE_91_01, NODE_91_02, NODE_91_03, NODE_91_04, NODE_91_05, NODE_91_06, NODE_91_07, 
        NODE_92 = 0x40000000 + 92 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_92_00 = NODE_92, NODE_92_01, NODE_92_02, NODE_92_03, NODE_92_04, NODE_92_05, NODE_92_06, NODE_92_07, 
        NODE_93 = 0x40000000 + 93 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_93_00 = NODE_93, NODE_93_01, NODE_93_02, NODE_93_03, NODE_93_04, NODE_93_05, NODE_93_06, NODE_93_07, 
        NODE_94 = 0x40000000 + 94 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_94_00 = NODE_94, NODE_94_01, NODE_94_02, NODE_94_03, NODE_94_04, NODE_94_05, NODE_94_06, NODE_94_07, 
        NODE_95 = 0x40000000 + 95 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_95_00 = NODE_95, NODE_95_01, NODE_95_02, NODE_95_03, NODE_95_04, NODE_95_05, NODE_95_06, NODE_95_07, 
        NODE_96 = 0x40000000 + 96 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_96_00 = NODE_96, NODE_96_01, NODE_96_02, NODE_96_03, NODE_96_04, NODE_96_05, NODE_96_06, NODE_96_07, 
        NODE_97 = 0x40000000 + 97 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_97_00 = NODE_97, NODE_97_01, NODE_97_02, NODE_97_03, NODE_97_04, NODE_97_05, NODE_97_06, NODE_97_07, 
        NODE_98 = 0x40000000 + 98 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_98_00 = NODE_98, NODE_98_01, NODE_98_02, NODE_98_03, NODE_98_04, NODE_98_05, NODE_98_06, NODE_98_07, 
        NODE_99 = 0x40000000 + 99 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_99_00 = NODE_99, NODE_99_01, NODE_99_02, NODE_99_03, NODE_99_04, NODE_99_05, NODE_99_06, NODE_99_07, 

        NODE_100 = 0x40000000 + 100 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_100_00 = NODE_100, NODE_100_01, NODE_100_02, NODE_100_03, NODE_100_04, NODE_100_05, NODE_100_06, NODE_100_07, 
        NODE_101 = 0x40000000 + 101 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_101_00 = NODE_101, NODE_101_01, NODE_101_02, NODE_101_03, NODE_101_04, NODE_101_05, NODE_101_06, NODE_101_07, 
        NODE_102 = 0x40000000 + 102 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_102_00 = NODE_102, NODE_102_01, NODE_102_02, NODE_102_03, NODE_102_04, NODE_102_05, NODE_102_06, NODE_102_07, 
        NODE_103 = 0x40000000 + 103 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_103_00 = NODE_103, NODE_103_01, NODE_103_02, NODE_103_03, NODE_103_04, NODE_103_05, NODE_103_06, NODE_103_07, 
        NODE_104 = 0x40000000 + 104 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_104_00 = NODE_104, NODE_104_01, NODE_104_02, NODE_104_03, NODE_104_04, NODE_104_05, NODE_104_06, NODE_104_07, 
        NODE_105 = 0x40000000 + 105 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_105_00 = NODE_105, NODE_105_01, NODE_105_02, NODE_105_03, NODE_105_04, NODE_105_05, NODE_105_06, NODE_105_07, 
        NODE_106 = 0x40000000 + 106 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_106_00 = NODE_106, NODE_106_01, NODE_106_02, NODE_106_03, NODE_106_04, NODE_106_05, NODE_106_06, NODE_106_07, 
        NODE_107 = 0x40000000 + 107 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_107_00 = NODE_107, NODE_107_01, NODE_107_02, NODE_107_03, NODE_107_04, NODE_107_05, NODE_107_06, NODE_107_07, 
        NODE_108 = 0x40000000 + 108 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_108_00 = NODE_108, NODE_108_01, NODE_108_02, NODE_108_03, NODE_108_04, NODE_108_05, NODE_108_06, NODE_108_07, 
        NODE_109 = 0x40000000 + 109 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_109_00 = NODE_109, NODE_109_01, NODE_109_02, NODE_109_03, NODE_109_04, NODE_109_05, NODE_109_06, NODE_109_07, 

        NODE_110 = 0x40000000 + 110 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_110_00 = NODE_110, NODE_110_01, NODE_110_02, NODE_110_03, NODE_110_04, NODE_110_05, NODE_110_06, NODE_110_07, 
        NODE_111 = 0x40000000 + 111 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_111_00 = NODE_111, NODE_111_01, NODE_111_02, NODE_111_03, NODE_111_04, NODE_111_05, NODE_111_06, NODE_111_07, 
        NODE_112 = 0x40000000 + 112 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_112_00 = NODE_112, NODE_112_01, NODE_112_02, NODE_112_03, NODE_112_04, NODE_112_05, NODE_112_06, NODE_112_07, 
        NODE_113 = 0x40000000 + 113 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_113_00 = NODE_113, NODE_113_01, NODE_113_02, NODE_113_03, NODE_113_04, NODE_113_05, NODE_113_06, NODE_113_07, 
        NODE_114 = 0x40000000 + 114 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_114_00 = NODE_114, NODE_114_01, NODE_114_02, NODE_114_03, NODE_114_04, NODE_114_05, NODE_114_06, NODE_114_07, 
        NODE_115 = 0x40000000 + 115 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_115_00 = NODE_115, NODE_115_01, NODE_115_02, NODE_115_03, NODE_115_04, NODE_115_05, NODE_115_06, NODE_115_07, 
        NODE_116 = 0x40000000 + 116 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_116_00 = NODE_116, NODE_116_01, NODE_116_02, NODE_116_03, NODE_116_04, NODE_116_05, NODE_116_06, NODE_116_07, 
        NODE_117 = 0x40000000 + 117 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_117_00 = NODE_117, NODE_117_01, NODE_117_02, NODE_117_03, NODE_117_04, NODE_117_05, NODE_117_06, NODE_117_07, 
        NODE_118 = 0x40000000 + 118 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_118_00 = NODE_118, NODE_118_01, NODE_118_02, NODE_118_03, NODE_118_04, NODE_118_05, NODE_118_06, NODE_118_07, 
        NODE_119 = 0x40000000 + 119 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_119_00 = NODE_119, NODE_119_01, NODE_119_02, NODE_119_03, NODE_119_04, NODE_119_05, NODE_119_06, NODE_119_07, 

        NODE_120 = 0x40000000 + 120 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_120_00 = NODE_120, NODE_120_01, NODE_120_02, NODE_120_03, NODE_120_04, NODE_120_05, NODE_120_06, NODE_120_07, 
        NODE_121 = 0x40000000 + 121 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_121_00 = NODE_121, NODE_121_01, NODE_121_02, NODE_121_03, NODE_121_04, NODE_121_05, NODE_121_06, NODE_121_07, 
        NODE_122 = 0x40000000 + 122 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_122_00 = NODE_122, NODE_122_01, NODE_122_02, NODE_122_03, NODE_122_04, NODE_122_05, NODE_122_06, NODE_122_07, 
        NODE_123 = 0x40000000 + 123 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_123_00 = NODE_123, NODE_123_01, NODE_123_02, NODE_123_03, NODE_123_04, NODE_123_05, NODE_123_06, NODE_123_07, 
        NODE_124 = 0x40000000 + 124 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_124_00 = NODE_124, NODE_124_01, NODE_124_02, NODE_124_03, NODE_124_04, NODE_124_05, NODE_124_06, NODE_124_07, 
        NODE_125 = 0x40000000 + 125 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_125_00 = NODE_125, NODE_125_01, NODE_125_02, NODE_125_03, NODE_125_04, NODE_125_05, NODE_125_06, NODE_125_07, 
        NODE_126 = 0x40000000 + 126 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_126_00 = NODE_126, NODE_126_01, NODE_126_02, NODE_126_03, NODE_126_04, NODE_126_05, NODE_126_06, NODE_126_07, 
        NODE_127 = 0x40000000 + 127 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_127_00 = NODE_127, NODE_127_01, NODE_127_02, NODE_127_03, NODE_127_04, NODE_127_05, NODE_127_06, NODE_127_07, 
        NODE_128 = 0x40000000 + 128 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_128_00 = NODE_128, NODE_128_01, NODE_128_02, NODE_128_03, NODE_128_04, NODE_128_05, NODE_128_06, NODE_128_07, 
        NODE_129 = 0x40000000 + 129 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_129_00 = NODE_129, NODE_129_01, NODE_129_02, NODE_129_03, NODE_129_04, NODE_129_05, NODE_129_06, NODE_129_07, 

        NODE_130 = 0x40000000 + 130 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_130_00 = NODE_130, NODE_130_01, NODE_130_02, NODE_130_03, NODE_130_04, NODE_130_05, NODE_130_06, NODE_130_07, 
        NODE_131 = 0x40000000 + 131 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_131_00 = NODE_131, NODE_131_01, NODE_131_02, NODE_131_03, NODE_131_04, NODE_131_05, NODE_131_06, NODE_131_07, 
        NODE_132 = 0x40000000 + 132 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_132_00 = NODE_132, NODE_132_01, NODE_132_02, NODE_132_03, NODE_132_04, NODE_132_05, NODE_132_06, NODE_132_07, 
        NODE_133 = 0x40000000 + 133 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_133_00 = NODE_133, NODE_133_01, NODE_133_02, NODE_133_03, NODE_133_04, NODE_133_05, NODE_133_06, NODE_133_07, 
        NODE_134 = 0x40000000 + 134 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_134_00 = NODE_134, NODE_134_01, NODE_134_02, NODE_134_03, NODE_134_04, NODE_134_05, NODE_134_06, NODE_134_07, 
        NODE_135 = 0x40000000 + 135 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_135_00 = NODE_135, NODE_135_01, NODE_135_02, NODE_135_03, NODE_135_04, NODE_135_05, NODE_135_06, NODE_135_07, 
        NODE_136 = 0x40000000 + 136 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_136_00 = NODE_136, NODE_136_01, NODE_136_02, NODE_136_03, NODE_136_04, NODE_136_05, NODE_136_06, NODE_136_07, 
        NODE_137 = 0x40000000 + 137 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_137_00 = NODE_137, NODE_137_01, NODE_137_02, NODE_137_03, NODE_137_04, NODE_137_05, NODE_137_06, NODE_137_07, 
        NODE_138 = 0x40000000 + 138 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_138_00 = NODE_138, NODE_138_01, NODE_138_02, NODE_138_03, NODE_138_04, NODE_138_05, NODE_138_06, NODE_138_07, 
        NODE_139 = 0x40000000 + 139 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_139_00 = NODE_139, NODE_139_01, NODE_139_02, NODE_139_03, NODE_139_04, NODE_139_05, NODE_139_06, NODE_139_07, 

        NODE_140 = 0x40000000 + 140 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_140_00 = NODE_140, NODE_140_01, NODE_140_02, NODE_140_03, NODE_140_04, NODE_140_05, NODE_140_06, NODE_140_07, 
        NODE_141 = 0x40000000 + 141 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_141_00 = NODE_141, NODE_141_01, NODE_141_02, NODE_141_03, NODE_141_04, NODE_141_05, NODE_141_06, NODE_141_07, 
        NODE_142 = 0x40000000 + 142 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_142_00 = NODE_142, NODE_142_01, NODE_142_02, NODE_142_03, NODE_142_04, NODE_142_05, NODE_142_06, NODE_142_07, 
        NODE_143 = 0x40000000 + 143 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_143_00 = NODE_143, NODE_143_01, NODE_143_02, NODE_143_03, NODE_143_04, NODE_143_05, NODE_143_06, NODE_143_07, 
        NODE_144 = 0x40000000 + 144 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_144_00 = NODE_144, NODE_144_01, NODE_144_02, NODE_144_03, NODE_144_04, NODE_144_05, NODE_144_06, NODE_144_07, 
        NODE_145 = 0x40000000 + 145 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_145_00 = NODE_145, NODE_145_01, NODE_145_02, NODE_145_03, NODE_145_04, NODE_145_05, NODE_145_06, NODE_145_07, 
        NODE_146 = 0x40000000 + 146 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_146_00 = NODE_146, NODE_146_01, NODE_146_02, NODE_146_03, NODE_146_04, NODE_146_05, NODE_146_06, NODE_146_07, 
        NODE_147 = 0x40000000 + 147 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_147_00 = NODE_147, NODE_147_01, NODE_147_02, NODE_147_03, NODE_147_04, NODE_147_05, NODE_147_06, NODE_147_07, 
        NODE_148 = 0x40000000 + 148 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_148_00 = NODE_148, NODE_148_01, NODE_148_02, NODE_148_03, NODE_148_04, NODE_148_05, NODE_148_06, NODE_148_07, 
        NODE_149 = 0x40000000 + 149 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_149_00 = NODE_149, NODE_149_01, NODE_149_02, NODE_149_03, NODE_149_04, NODE_149_05, NODE_149_06, NODE_149_07, 

        NODE_150 = 0x40000000 + 150 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_150_00 = NODE_150, NODE_150_01, NODE_150_02, NODE_150_03, NODE_150_04, NODE_150_05, NODE_150_06, NODE_150_07, 
        NODE_151 = 0x40000000 + 151 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_151_00 = NODE_151, NODE_151_01, NODE_151_02, NODE_151_03, NODE_151_04, NODE_151_05, NODE_151_06, NODE_151_07, 
        NODE_152 = 0x40000000 + 152 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_152_00 = NODE_152, NODE_152_01, NODE_152_02, NODE_152_03, NODE_152_04, NODE_152_05, NODE_152_06, NODE_152_07, 
        NODE_153 = 0x40000000 + 153 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_153_00 = NODE_153, NODE_153_01, NODE_153_02, NODE_153_03, NODE_153_04, NODE_153_05, NODE_153_06, NODE_153_07, 
        NODE_154 = 0x40000000 + 154 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_154_00 = NODE_154, NODE_154_01, NODE_154_02, NODE_154_03, NODE_154_04, NODE_154_05, NODE_154_06, NODE_154_07, 
        NODE_155 = 0x40000000 + 155 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_155_00 = NODE_155, NODE_155_01, NODE_155_02, NODE_155_03, NODE_155_04, NODE_155_05, NODE_155_06, NODE_155_07, 
        NODE_156 = 0x40000000 + 156 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_156_00 = NODE_156, NODE_156_01, NODE_156_02, NODE_156_03, NODE_156_04, NODE_156_05, NODE_156_06, NODE_156_07, 
        NODE_157 = 0x40000000 + 157 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_157_00 = NODE_157, NODE_157_01, NODE_157_02, NODE_157_03, NODE_157_04, NODE_157_05, NODE_157_06, NODE_157_07, 
        NODE_158 = 0x40000000 + 158 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_158_00 = NODE_158, NODE_158_01, NODE_158_02, NODE_158_03, NODE_158_04, NODE_158_05, NODE_158_06, NODE_158_07, 
        NODE_159 = 0x40000000 + 159 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_159_00 = NODE_159, NODE_159_01, NODE_159_02, NODE_159_03, NODE_159_04, NODE_159_05, NODE_159_06, NODE_159_07, 

        NODE_160 = 0x40000000 + 160 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_160_00 = NODE_160, NODE_160_01, NODE_160_02, NODE_160_03, NODE_160_04, NODE_160_05, NODE_160_06, NODE_160_07, 
        NODE_161 = 0x40000000 + 161 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_161_00 = NODE_161, NODE_161_01, NODE_161_02, NODE_161_03, NODE_161_04, NODE_161_05, NODE_161_06, NODE_161_07, 
        NODE_162 = 0x40000000 + 162 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_162_00 = NODE_162, NODE_162_01, NODE_162_02, NODE_162_03, NODE_162_04, NODE_162_05, NODE_162_06, NODE_162_07, 
        NODE_163 = 0x40000000 + 163 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_163_00 = NODE_163, NODE_163_01, NODE_163_02, NODE_163_03, NODE_163_04, NODE_163_05, NODE_163_06, NODE_163_07, 
        NODE_164 = 0x40000000 + 164 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_164_00 = NODE_164, NODE_164_01, NODE_164_02, NODE_164_03, NODE_164_04, NODE_164_05, NODE_164_06, NODE_164_07, 
        NODE_165 = 0x40000000 + 165 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_165_00 = NODE_165, NODE_165_01, NODE_165_02, NODE_165_03, NODE_165_04, NODE_165_05, NODE_165_06, NODE_165_07, 
        NODE_166 = 0x40000000 + 166 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_166_00 = NODE_166, NODE_166_01, NODE_166_02, NODE_166_03, NODE_166_04, NODE_166_05, NODE_166_06, NODE_166_07, 
        NODE_167 = 0x40000000 + 167 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_167_00 = NODE_167, NODE_167_01, NODE_167_02, NODE_167_03, NODE_167_04, NODE_167_05, NODE_167_06, NODE_167_07, 
        NODE_168 = 0x40000000 + 168 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_168_00 = NODE_168, NODE_168_01, NODE_168_02, NODE_168_03, NODE_168_04, NODE_168_05, NODE_168_06, NODE_168_07, 
        NODE_169 = 0x40000000 + 169 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_169_00 = NODE_169, NODE_169_01, NODE_169_02, NODE_169_03, NODE_169_04, NODE_169_05, NODE_169_06, NODE_169_07, 

        NODE_170 = 0x40000000 + 170 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_170_00 = NODE_170, NODE_170_01, NODE_170_02, NODE_170_03, NODE_170_04, NODE_170_05, NODE_170_06, NODE_170_07, 
        NODE_171 = 0x40000000 + 171 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_171_00 = NODE_171, NODE_171_01, NODE_171_02, NODE_171_03, NODE_171_04, NODE_171_05, NODE_171_06, NODE_171_07, 
        NODE_172 = 0x40000000 + 172 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_172_00 = NODE_172, NODE_172_01, NODE_172_02, NODE_172_03, NODE_172_04, NODE_172_05, NODE_172_06, NODE_172_07, 
        NODE_173 = 0x40000000 + 173 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_173_00 = NODE_173, NODE_173_01, NODE_173_02, NODE_173_03, NODE_173_04, NODE_173_05, NODE_173_06, NODE_173_07, 
        NODE_174 = 0x40000000 + 174 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_174_00 = NODE_174, NODE_174_01, NODE_174_02, NODE_174_03, NODE_174_04, NODE_174_05, NODE_174_06, NODE_174_07, 
        NODE_175 = 0x40000000 + 175 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_175_00 = NODE_175, NODE_175_01, NODE_175_02, NODE_175_03, NODE_175_04, NODE_175_05, NODE_175_06, NODE_175_07, 
        NODE_176 = 0x40000000 + 176 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_176_00 = NODE_176, NODE_176_01, NODE_176_02, NODE_176_03, NODE_176_04, NODE_176_05, NODE_176_06, NODE_176_07, 
        NODE_177 = 0x40000000 + 177 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_177_00 = NODE_177, NODE_177_01, NODE_177_02, NODE_177_03, NODE_177_04, NODE_177_05, NODE_177_06, NODE_177_07, 
        NODE_178 = 0x40000000 + 178 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_178_00 = NODE_178, NODE_178_01, NODE_178_02, NODE_178_03, NODE_178_04, NODE_178_05, NODE_178_06, NODE_178_07, 
        NODE_179 = 0x40000000 + 179 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_179_00 = NODE_179, NODE_179_01, NODE_179_02, NODE_179_03, NODE_179_04, NODE_179_05, NODE_179_06, NODE_179_07, 

        NODE_180 = 0x40000000 + 180 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_180_00 = NODE_180, NODE_180_01, NODE_180_02, NODE_180_03, NODE_180_04, NODE_180_05, NODE_180_06, NODE_180_07, 
        NODE_181 = 0x40000000 + 181 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_181_00 = NODE_181, NODE_181_01, NODE_181_02, NODE_181_03, NODE_181_04, NODE_181_05, NODE_181_06, NODE_181_07, 
        NODE_182 = 0x40000000 + 182 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_182_00 = NODE_182, NODE_182_01, NODE_182_02, NODE_182_03, NODE_182_04, NODE_182_05, NODE_182_06, NODE_182_07, 
        NODE_183 = 0x40000000 + 183 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_183_00 = NODE_183, NODE_183_01, NODE_183_02, NODE_183_03, NODE_183_04, NODE_183_05, NODE_183_06, NODE_183_07, 
        NODE_184 = 0x40000000 + 184 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_184_00 = NODE_184, NODE_184_01, NODE_184_02, NODE_184_03, NODE_184_04, NODE_184_05, NODE_184_06, NODE_184_07, 
        NODE_185 = 0x40000000 + 185 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_185_00 = NODE_185, NODE_185_01, NODE_185_02, NODE_185_03, NODE_185_04, NODE_185_05, NODE_185_06, NODE_185_07, 
        NODE_186 = 0x40000000 + 186 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_186_00 = NODE_186, NODE_186_01, NODE_186_02, NODE_186_03, NODE_186_04, NODE_186_05, NODE_186_06, NODE_186_07, 
        NODE_187 = 0x40000000 + 187 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_187_00 = NODE_187, NODE_187_01, NODE_187_02, NODE_187_03, NODE_187_04, NODE_187_05, NODE_187_06, NODE_187_07, 
        NODE_188 = 0x40000000 + 188 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_188_00 = NODE_188, NODE_188_01, NODE_188_02, NODE_188_03, NODE_188_04, NODE_188_05, NODE_188_06, NODE_188_07, 
        NODE_189 = 0x40000000 + 189 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_189_00 = NODE_189, NODE_189_01, NODE_189_02, NODE_189_03, NODE_189_04, NODE_189_05, NODE_189_06, NODE_189_07, 

        NODE_190 = 0x40000000 + 190 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_190_00 = NODE_190, NODE_190_01, NODE_190_02, NODE_190_03, NODE_190_04, NODE_190_05, NODE_190_06, NODE_190_07, 
        NODE_191 = 0x40000000 + 191 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_191_00 = NODE_191, NODE_191_01, NODE_191_02, NODE_191_03, NODE_191_04, NODE_191_05, NODE_191_06, NODE_191_07, 
        NODE_192 = 0x40000000 + 192 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_192_00 = NODE_192, NODE_192_01, NODE_192_02, NODE_192_03, NODE_192_04, NODE_192_05, NODE_192_06, NODE_192_07, 
        NODE_193 = 0x40000000 + 193 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_193_00 = NODE_193, NODE_193_01, NODE_193_02, NODE_193_03, NODE_193_04, NODE_193_05, NODE_193_06, NODE_193_07, 
        NODE_194 = 0x40000000 + 194 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_194_00 = NODE_194, NODE_194_01, NODE_194_02, NODE_194_03, NODE_194_04, NODE_194_05, NODE_194_06, NODE_194_07, 
        NODE_195 = 0x40000000 + 195 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_195_00 = NODE_195, NODE_195_01, NODE_195_02, NODE_195_03, NODE_195_04, NODE_195_05, NODE_195_06, NODE_195_07, 
        NODE_196 = 0x40000000 + 196 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_196_00 = NODE_196, NODE_196_01, NODE_196_02, NODE_196_03, NODE_196_04, NODE_196_05, NODE_196_06, NODE_196_07, 
        NODE_197 = 0x40000000 + 197 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_197_00 = NODE_197, NODE_197_01, NODE_197_02, NODE_197_03, NODE_197_04, NODE_197_05, NODE_197_06, NODE_197_07, 
        NODE_198 = 0x40000000 + 198 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_198_00 = NODE_198, NODE_198_01, NODE_198_02, NODE_198_03, NODE_198_04, NODE_198_05, NODE_198_06, NODE_198_07, 
        NODE_199 = 0x40000000 + 199 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_199_00 = NODE_199, NODE_199_01, NODE_199_02, NODE_199_03, NODE_199_04, NODE_199_05, NODE_199_06, NODE_199_07, 

        NODE_200 = 0x40000000 + 200 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_200_00 = NODE_200, NODE_200_01, NODE_200_02, NODE_200_03, NODE_200_04, NODE_200_05, NODE_200_06, NODE_200_07, 
        NODE_201 = 0x40000000 + 201 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_201_00 = NODE_201, NODE_201_01, NODE_201_02, NODE_201_03, NODE_201_04, NODE_201_05, NODE_201_06, NODE_201_07, 
        NODE_202 = 0x40000000 + 202 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_202_00 = NODE_202, NODE_202_01, NODE_202_02, NODE_202_03, NODE_202_04, NODE_202_05, NODE_202_06, NODE_202_07, 
        NODE_203 = 0x40000000 + 203 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_203_00 = NODE_203, NODE_203_01, NODE_203_02, NODE_203_03, NODE_203_04, NODE_203_05, NODE_203_06, NODE_203_07, 
        NODE_204 = 0x40000000 + 204 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_204_00 = NODE_204, NODE_204_01, NODE_204_02, NODE_204_03, NODE_204_04, NODE_204_05, NODE_204_06, NODE_204_07, 
        NODE_205 = 0x40000000 + 205 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_205_00 = NODE_205, NODE_205_01, NODE_205_02, NODE_205_03, NODE_205_04, NODE_205_05, NODE_205_06, NODE_205_07, 
        NODE_206 = 0x40000000 + 206 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_206_00 = NODE_206, NODE_206_01, NODE_206_02, NODE_206_03, NODE_206_04, NODE_206_05, NODE_206_06, NODE_206_07, 
        NODE_207 = 0x40000000 + 207 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_207_00 = NODE_207, NODE_207_01, NODE_207_02, NODE_207_03, NODE_207_04, NODE_207_05, NODE_207_06, NODE_207_07, 
        NODE_208 = 0x40000000 + 208 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_208_00 = NODE_208, NODE_208_01, NODE_208_02, NODE_208_03, NODE_208_04, NODE_208_05, NODE_208_06, NODE_208_07, 
        NODE_209 = 0x40000000 + 209 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_209_00 = NODE_209, NODE_209_01, NODE_209_02, NODE_209_03, NODE_209_04, NODE_209_05, NODE_209_06, NODE_209_07, 

        NODE_210 = 0x40000000 + 210 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_210_00 = NODE_210, NODE_210_01, NODE_210_02, NODE_210_03, NODE_210_04, NODE_210_05, NODE_210_06, NODE_210_07, 
        NODE_211 = 0x40000000 + 211 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_211_00 = NODE_211, NODE_211_01, NODE_211_02, NODE_211_03, NODE_211_04, NODE_211_05, NODE_211_06, NODE_211_07, 
        NODE_212 = 0x40000000 + 212 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_212_00 = NODE_212, NODE_212_01, NODE_212_02, NODE_212_03, NODE_212_04, NODE_212_05, NODE_212_06, NODE_212_07, 
        NODE_213 = 0x40000000 + 213 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_213_00 = NODE_213, NODE_213_01, NODE_213_02, NODE_213_03, NODE_213_04, NODE_213_05, NODE_213_06, NODE_213_07, 
        NODE_214 = 0x40000000 + 214 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_214_00 = NODE_214, NODE_214_01, NODE_214_02, NODE_214_03, NODE_214_04, NODE_214_05, NODE_214_06, NODE_214_07, 
        NODE_215 = 0x40000000 + 215 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_215_00 = NODE_215, NODE_215_01, NODE_215_02, NODE_215_03, NODE_215_04, NODE_215_05, NODE_215_06, NODE_215_07, 
        NODE_216 = 0x40000000 + 216 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_216_00 = NODE_216, NODE_216_01, NODE_216_02, NODE_216_03, NODE_216_04, NODE_216_05, NODE_216_06, NODE_216_07, 
        NODE_217 = 0x40000000 + 217 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_217_00 = NODE_217, NODE_217_01, NODE_217_02, NODE_217_03, NODE_217_04, NODE_217_05, NODE_217_06, NODE_217_07, 
        NODE_218 = 0x40000000 + 218 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_218_00 = NODE_218, NODE_218_01, NODE_218_02, NODE_218_03, NODE_218_04, NODE_218_05, NODE_218_06, NODE_218_07, 
        NODE_219 = 0x40000000 + 219 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_219_00 = NODE_219, NODE_219_01, NODE_219_02, NODE_219_03, NODE_219_04, NODE_219_05, NODE_219_06, NODE_219_07, 

        NODE_220 = 0x40000000 + 220 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_220_00 = NODE_220, NODE_220_01, NODE_220_02, NODE_220_03, NODE_220_04, NODE_220_05, NODE_220_06, NODE_220_07, 
        NODE_221 = 0x40000000 + 221 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_221_00 = NODE_221, NODE_221_01, NODE_221_02, NODE_221_03, NODE_221_04, NODE_221_05, NODE_221_06, NODE_221_07, 
        NODE_222 = 0x40000000 + 222 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_222_00 = NODE_222, NODE_222_01, NODE_222_02, NODE_222_03, NODE_222_04, NODE_222_05, NODE_222_06, NODE_222_07, 
        NODE_223 = 0x40000000 + 223 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_223_00 = NODE_223, NODE_223_01, NODE_223_02, NODE_223_03, NODE_223_04, NODE_223_05, NODE_223_06, NODE_223_07, 
        NODE_224 = 0x40000000 + 224 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_224_00 = NODE_224, NODE_224_01, NODE_224_02, NODE_224_03, NODE_224_04, NODE_224_05, NODE_224_06, NODE_224_07, 
        NODE_225 = 0x40000000 + 225 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_225_00 = NODE_225, NODE_225_01, NODE_225_02, NODE_225_03, NODE_225_04, NODE_225_05, NODE_225_06, NODE_225_07, 
        NODE_226 = 0x40000000 + 226 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_226_00 = NODE_226, NODE_226_01, NODE_226_02, NODE_226_03, NODE_226_04, NODE_226_05, NODE_226_06, NODE_226_07, 
        NODE_227 = 0x40000000 + 227 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_227_00 = NODE_227, NODE_227_01, NODE_227_02, NODE_227_03, NODE_227_04, NODE_227_05, NODE_227_06, NODE_227_07, 
        NODE_228 = 0x40000000 + 228 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_228_00 = NODE_228, NODE_228_01, NODE_228_02, NODE_228_03, NODE_228_04, NODE_228_05, NODE_228_06, NODE_228_07, 
        NODE_229 = 0x40000000 + 229 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_229_00 = NODE_229, NODE_229_01, NODE_229_02, NODE_229_03, NODE_229_04, NODE_229_05, NODE_229_06, NODE_229_07, 

        NODE_230 = 0x40000000 + 230 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_230_00 = NODE_230, NODE_230_01, NODE_230_02, NODE_230_03, NODE_230_04, NODE_230_05, NODE_230_06, NODE_230_07, 
        NODE_231 = 0x40000000 + 231 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_231_00 = NODE_231, NODE_231_01, NODE_231_02, NODE_231_03, NODE_231_04, NODE_231_05, NODE_231_06, NODE_231_07, 
        NODE_232 = 0x40000000 + 232 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_232_00 = NODE_232, NODE_232_01, NODE_232_02, NODE_232_03, NODE_232_04, NODE_232_05, NODE_232_06, NODE_232_07, 
        NODE_233 = 0x40000000 + 233 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_233_00 = NODE_233, NODE_233_01, NODE_233_02, NODE_233_03, NODE_233_04, NODE_233_05, NODE_233_06, NODE_233_07, 
        NODE_234 = 0x40000000 + 234 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_234_00 = NODE_234, NODE_234_01, NODE_234_02, NODE_234_03, NODE_234_04, NODE_234_05, NODE_234_06, NODE_234_07, 
        NODE_235 = 0x40000000 + 235 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_235_00 = NODE_235, NODE_235_01, NODE_235_02, NODE_235_03, NODE_235_04, NODE_235_05, NODE_235_06, NODE_235_07, 
        NODE_236 = 0x40000000 + 236 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_236_00 = NODE_236, NODE_236_01, NODE_236_02, NODE_236_03, NODE_236_04, NODE_236_05, NODE_236_06, NODE_236_07, 
        NODE_237 = 0x40000000 + 237 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_237_00 = NODE_237, NODE_237_01, NODE_237_02, NODE_237_03, NODE_237_04, NODE_237_05, NODE_237_06, NODE_237_07, 
        NODE_238 = 0x40000000 + 238 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_238_00 = NODE_238, NODE_238_01, NODE_238_02, NODE_238_03, NODE_238_04, NODE_238_05, NODE_238_06, NODE_238_07, 
        NODE_239 = 0x40000000 + 239 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_239_00 = NODE_239, NODE_239_01, NODE_239_02, NODE_239_03, NODE_239_04, NODE_239_05, NODE_239_06, NODE_239_07, 

        NODE_240 = 0x40000000 + 240 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_240_00 = NODE_240, NODE_240_01, NODE_240_02, NODE_240_03, NODE_240_04, NODE_240_05, NODE_240_06, NODE_240_07, 
        NODE_241 = 0x40000000 + 241 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_241_00 = NODE_241, NODE_241_01, NODE_241_02, NODE_241_03, NODE_241_04, NODE_241_05, NODE_241_06, NODE_241_07, 
        NODE_242 = 0x40000000 + 242 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_242_00 = NODE_242, NODE_242_01, NODE_242_02, NODE_242_03, NODE_242_04, NODE_242_05, NODE_242_06, NODE_242_07, 
        NODE_243 = 0x40000000 + 243 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_243_00 = NODE_243, NODE_243_01, NODE_243_02, NODE_243_03, NODE_243_04, NODE_243_05, NODE_243_06, NODE_243_07, 
        NODE_244 = 0x40000000 + 244 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_244_00 = NODE_244, NODE_244_01, NODE_244_02, NODE_244_03, NODE_244_04, NODE_244_05, NODE_244_06, NODE_244_07, 
        NODE_245 = 0x40000000 + 245 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_245_00 = NODE_245, NODE_245_01, NODE_245_02, NODE_245_03, NODE_245_04, NODE_245_05, NODE_245_06, NODE_245_07, 
        NODE_246 = 0x40000000 + 246 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_246_00 = NODE_246, NODE_246_01, NODE_246_02, NODE_246_03, NODE_246_04, NODE_246_05, NODE_246_06, NODE_246_07, 
        NODE_247 = 0x40000000 + 247 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_247_00 = NODE_247, NODE_247_01, NODE_247_02, NODE_247_03, NODE_247_04, NODE_247_05, NODE_247_06, NODE_247_07, 
        NODE_248 = 0x40000000 + 248 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_248_00 = NODE_248, NODE_248_01, NODE_248_02, NODE_248_03, NODE_248_04, NODE_248_05, NODE_248_06, NODE_248_07, 
        NODE_249 = 0x40000000 + 249 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_249_00 = NODE_249, NODE_249_01, NODE_249_02, NODE_249_03, NODE_249_04, NODE_249_05, NODE_249_06, NODE_249_07, 

        NODE_250 = 0x40000000 + 250 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_250_00 = NODE_250, NODE_250_01, NODE_250_02, NODE_250_03, NODE_250_04, NODE_250_05, NODE_250_06, NODE_250_07, 
        NODE_251 = 0x40000000 + 251 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_251_00 = NODE_251, NODE_251_01, NODE_251_02, NODE_251_03, NODE_251_04, NODE_251_05, NODE_251_06, NODE_251_07, 
        NODE_252 = 0x40000000 + 252 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_252_00 = NODE_252, NODE_252_01, NODE_252_02, NODE_252_03, NODE_252_04, NODE_252_05, NODE_252_06, NODE_252_07, 
        NODE_253 = 0x40000000 + 253 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_253_00 = NODE_253, NODE_253_01, NODE_253_02, NODE_253_03, NODE_253_04, NODE_253_05, NODE_253_06, NODE_253_07, 
        NODE_254 = 0x40000000 + 254 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_254_00 = NODE_254, NODE_254_01, NODE_254_02, NODE_254_03, NODE_254_04, NODE_254_05, NODE_254_06, NODE_254_07, 
        NODE_255 = 0x40000000 + 255 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_255_00 = NODE_255, NODE_255_01, NODE_255_02, NODE_255_03, NODE_255_04, NODE_255_05, NODE_255_06, NODE_255_07, 
        NODE_256 = 0x40000000 + 256 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_256_00 = NODE_256, NODE_256_01, NODE_256_02, NODE_256_03, NODE_256_04, NODE_256_05, NODE_256_06, NODE_256_07, 
        NODE_257 = 0x40000000 + 257 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_257_00 = NODE_257, NODE_257_01, NODE_257_02, NODE_257_03, NODE_257_04, NODE_257_05, NODE_257_06, NODE_257_07, 
        NODE_258 = 0x40000000 + 258 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_258_00 = NODE_258, NODE_258_01, NODE_258_02, NODE_258_03, NODE_258_04, NODE_258_05, NODE_258_06, NODE_258_07, 
        NODE_259 = 0x40000000 + 259 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_259_00 = NODE_259, NODE_259_01, NODE_259_02, NODE_259_03, NODE_259_04, NODE_259_05, NODE_259_06, NODE_259_07, 

        NODE_260 = 0x40000000 + 260 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_260_00 = NODE_260, NODE_260_01, NODE_260_02, NODE_260_03, NODE_260_04, NODE_260_05, NODE_260_06, NODE_260_07, 
        NODE_261 = 0x40000000 + 261 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_261_00 = NODE_261, NODE_261_01, NODE_261_02, NODE_261_03, NODE_261_04, NODE_261_05, NODE_261_06, NODE_261_07, 
        NODE_262 = 0x40000000 + 262 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_262_00 = NODE_262, NODE_262_01, NODE_262_02, NODE_262_03, NODE_262_04, NODE_262_05, NODE_262_06, NODE_262_07, 
        NODE_263 = 0x40000000 + 263 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_263_00 = NODE_263, NODE_263_01, NODE_263_02, NODE_263_03, NODE_263_04, NODE_263_05, NODE_263_06, NODE_263_07, 
        NODE_264 = 0x40000000 + 264 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_264_00 = NODE_264, NODE_264_01, NODE_264_02, NODE_264_03, NODE_264_04, NODE_264_05, NODE_264_06, NODE_264_07, 
        NODE_265 = 0x40000000 + 265 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_265_00 = NODE_265, NODE_265_01, NODE_265_02, NODE_265_03, NODE_265_04, NODE_265_05, NODE_265_06, NODE_265_07, 
        NODE_266 = 0x40000000 + 266 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_266_00 = NODE_266, NODE_266_01, NODE_266_02, NODE_266_03, NODE_266_04, NODE_266_05, NODE_266_06, NODE_266_07, 
        NODE_267 = 0x40000000 + 267 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_267_00 = NODE_267, NODE_267_01, NODE_267_02, NODE_267_03, NODE_267_04, NODE_267_05, NODE_267_06, NODE_267_07, 
        NODE_268 = 0x40000000 + 268 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_268_00 = NODE_268, NODE_268_01, NODE_268_02, NODE_268_03, NODE_268_04, NODE_268_05, NODE_268_06, NODE_268_07, 
        NODE_269 = 0x40000000 + 269 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_269_00 = NODE_269, NODE_269_01, NODE_269_02, NODE_269_03, NODE_269_04, NODE_269_05, NODE_269_06, NODE_269_07, 

        NODE_270 = 0x40000000 + 270 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_270_00 = NODE_270, NODE_270_01, NODE_270_02, NODE_270_03, NODE_270_04, NODE_270_05, NODE_270_06, NODE_270_07, 
        NODE_271 = 0x40000000 + 271 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_271_00 = NODE_271, NODE_271_01, NODE_271_02, NODE_271_03, NODE_271_04, NODE_271_05, NODE_271_06, NODE_271_07, 
        NODE_272 = 0x40000000 + 272 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_272_00 = NODE_272, NODE_272_01, NODE_272_02, NODE_272_03, NODE_272_04, NODE_272_05, NODE_272_06, NODE_272_07, 
        NODE_273 = 0x40000000 + 273 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_273_00 = NODE_273, NODE_273_01, NODE_273_02, NODE_273_03, NODE_273_04, NODE_273_05, NODE_273_06, NODE_273_07, 
        NODE_274 = 0x40000000 + 274 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_274_00 = NODE_274, NODE_274_01, NODE_274_02, NODE_274_03, NODE_274_04, NODE_274_05, NODE_274_06, NODE_274_07, 
        NODE_275 = 0x40000000 + 275 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_275_00 = NODE_275, NODE_275_01, NODE_275_02, NODE_275_03, NODE_275_04, NODE_275_05, NODE_275_06, NODE_275_07, 
        NODE_276 = 0x40000000 + 276 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_276_00 = NODE_276, NODE_276_01, NODE_276_02, NODE_276_03, NODE_276_04, NODE_276_05, NODE_276_06, NODE_276_07, 
        NODE_277 = 0x40000000 + 277 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_277_00 = NODE_277, NODE_277_01, NODE_277_02, NODE_277_03, NODE_277_04, NODE_277_05, NODE_277_06, NODE_277_07, 
        NODE_278 = 0x40000000 + 278 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_278_00 = NODE_278, NODE_278_01, NODE_278_02, NODE_278_03, NODE_278_04, NODE_278_05, NODE_278_06, NODE_278_07, 
        NODE_279 = 0x40000000 + 279 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_279_00 = NODE_279, NODE_279_01, NODE_279_02, NODE_279_03, NODE_279_04, NODE_279_05, NODE_279_06, NODE_279_07, 

        NODE_280 = 0x40000000 + 280 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_280_00 = NODE_280, NODE_280_01, NODE_280_02, NODE_280_03, NODE_280_04, NODE_280_05, NODE_280_06, NODE_280_07, 
        NODE_281 = 0x40000000 + 281 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_281_00 = NODE_281, NODE_281_01, NODE_281_02, NODE_281_03, NODE_281_04, NODE_281_05, NODE_281_06, NODE_281_07, 
        NODE_282 = 0x40000000 + 282 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_282_00 = NODE_282, NODE_282_01, NODE_282_02, NODE_282_03, NODE_282_04, NODE_282_05, NODE_282_06, NODE_282_07, 
        NODE_283 = 0x40000000 + 283 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_283_00 = NODE_283, NODE_283_01, NODE_283_02, NODE_283_03, NODE_283_04, NODE_283_05, NODE_283_06, NODE_283_07, 
        NODE_284 = 0x40000000 + 284 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_284_00 = NODE_284, NODE_284_01, NODE_284_02, NODE_284_03, NODE_284_04, NODE_284_05, NODE_284_06, NODE_284_07, 
        NODE_285 = 0x40000000 + 285 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_285_00 = NODE_285, NODE_285_01, NODE_285_02, NODE_285_03, NODE_285_04, NODE_285_05, NODE_285_06, NODE_285_07, 
        NODE_286 = 0x40000000 + 286 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_286_00 = NODE_286, NODE_286_01, NODE_286_02, NODE_286_03, NODE_286_04, NODE_286_05, NODE_286_06, NODE_286_07, 
        NODE_287 = 0x40000000 + 287 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_287_00 = NODE_287, NODE_287_01, NODE_287_02, NODE_287_03, NODE_287_04, NODE_287_05, NODE_287_06, NODE_287_07, 
        NODE_288 = 0x40000000 + 288 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_288_00 = NODE_288, NODE_288_01, NODE_288_02, NODE_288_03, NODE_288_04, NODE_288_05, NODE_288_06, NODE_288_07, 
        NODE_289 = 0x40000000 + 289 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_289_00 = NODE_289, NODE_289_01, NODE_289_02, NODE_289_03, NODE_289_04, NODE_289_05, NODE_289_06, NODE_289_07, 

        NODE_290 = 0x40000000 + 290 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_290_00 = NODE_290, NODE_290_01, NODE_290_02, NODE_290_03, NODE_290_04, NODE_290_05, NODE_290_06, NODE_290_07, 
        NODE_291 = 0x40000000 + 291 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_291_00 = NODE_291, NODE_291_01, NODE_291_02, NODE_291_03, NODE_291_04, NODE_291_05, NODE_291_06, NODE_291_07, 
        NODE_292 = 0x40000000 + 292 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_292_00 = NODE_292, NODE_292_01, NODE_292_02, NODE_292_03, NODE_292_04, NODE_292_05, NODE_292_06, NODE_292_07, 
        NODE_293 = 0x40000000 + 293 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_293_00 = NODE_293, NODE_293_01, NODE_293_02, NODE_293_03, NODE_293_04, NODE_293_05, NODE_293_06, NODE_293_07, 
        NODE_294 = 0x40000000 + 294 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_294_00 = NODE_294, NODE_294_01, NODE_294_02, NODE_294_03, NODE_294_04, NODE_294_05, NODE_294_06, NODE_294_07, 
        NODE_295 = 0x40000000 + 295 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_295_00 = NODE_295, NODE_295_01, NODE_295_02, NODE_295_03, NODE_295_04, NODE_295_05, NODE_295_06, NODE_295_07, 
        NODE_296 = 0x40000000 + 296 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_296_00 = NODE_296, NODE_296_01, NODE_296_02, NODE_296_03, NODE_296_04, NODE_296_05, NODE_296_06, NODE_296_07, 
        NODE_297 = 0x40000000 + 297 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_297_00 = NODE_297, NODE_297_01, NODE_297_02, NODE_297_03, NODE_297_04, NODE_297_05, NODE_297_06, NODE_297_07, 
        NODE_298 = 0x40000000 + 298 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_298_00 = NODE_298, NODE_298_01, NODE_298_02, NODE_298_03, NODE_298_04, NODE_298_05, NODE_298_06, NODE_298_07, 
        NODE_299 = 0x40000000 + 299 * discrete_global.DISCRETE_MAX_OUTPUTS, NODE_299_00 = NODE_299, NODE_299_01, NODE_299_02, NODE_299_03, NODE_299_04, NODE_299_05, NODE_299_06, NODE_299_07, 

#if false
        NODE0_DEF(0), NODE0_DEF(1), NODE0_DEF(2), NODE0_DEF(3), NODE0_DEF(4), NODE0_DEF(5), NODE0_DEF(6), NODE0_DEF(7), NODE0_DEF(8), NODE0_DEF(9),
        NODE_DEF(10), NODE_DEF(11), NODE_DEF(12), NODE_DEF(13), NODE_DEF(14), NODE_DEF(15), NODE_DEF(16), NODE_DEF(17), NODE_DEF(18), NODE_DEF(19),
        NODE_DEF(20), NODE_DEF(21), NODE_DEF(22), NODE_DEF(23), NODE_DEF(24), NODE_DEF(25), NODE_DEF(26), NODE_DEF(27), NODE_DEF(28), NODE_DEF(29),
        NODE_DEF(30), NODE_DEF(31), NODE_DEF(32), NODE_DEF(33), NODE_DEF(34), NODE_DEF(35), NODE_DEF(36), NODE_DEF(37), NODE_DEF(38), NODE_DEF(39),
        NODE_DEF(40), NODE_DEF(41), NODE_DEF(42), NODE_DEF(43), NODE_DEF(44), NODE_DEF(45), NODE_DEF(46), NODE_DEF(47), NODE_DEF(48), NODE_DEF(49),
        NODE_DEF(50), NODE_DEF(51), NODE_DEF(52), NODE_DEF(53), NODE_DEF(54), NODE_DEF(55), NODE_DEF(56), NODE_DEF(57), NODE_DEF(58), NODE_DEF(59),
        NODE_DEF(60), NODE_DEF(61), NODE_DEF(62), NODE_DEF(63), NODE_DEF(64), NODE_DEF(65), NODE_DEF(66), NODE_DEF(67), NODE_DEF(68), NODE_DEF(69),
        NODE_DEF(70), NODE_DEF(71), NODE_DEF(72), NODE_DEF(73), NODE_DEF(74), NODE_DEF(75), NODE_DEF(76), NODE_DEF(77), NODE_DEF(78), NODE_DEF(79),
        NODE_DEF(80), NODE_DEF(81), NODE_DEF(82), NODE_DEF(83), NODE_DEF(84), NODE_DEF(85), NODE_DEF(86), NODE_DEF(87), NODE_DEF(88), NODE_DEF(89),
        NODE_DEF(90), NODE_DEF(91), NODE_DEF(92), NODE_DEF(93), NODE_DEF(94), NODE_DEF(95), NODE_DEF(96), NODE_DEF(97), NODE_DEF(98), NODE_DEF(99),
        NODE_DEF(100),NODE_DEF(101),NODE_DEF(102),NODE_DEF(103),NODE_DEF(104),NODE_DEF(105),NODE_DEF(106),NODE_DEF(107),NODE_DEF(108),NODE_DEF(109),
        NODE_DEF(110),NODE_DEF(111),NODE_DEF(112),NODE_DEF(113),NODE_DEF(114),NODE_DEF(115),NODE_DEF(116),NODE_DEF(117),NODE_DEF(118),NODE_DEF(119),
        NODE_DEF(120),NODE_DEF(121),NODE_DEF(122),NODE_DEF(123),NODE_DEF(124),NODE_DEF(125),NODE_DEF(126),NODE_DEF(127),NODE_DEF(128),NODE_DEF(129),
        NODE_DEF(130),NODE_DEF(131),NODE_DEF(132),NODE_DEF(133),NODE_DEF(134),NODE_DEF(135),NODE_DEF(136),NODE_DEF(137),NODE_DEF(138),NODE_DEF(139),
        NODE_DEF(140),NODE_DEF(141),NODE_DEF(142),NODE_DEF(143),NODE_DEF(144),NODE_DEF(145),NODE_DEF(146),NODE_DEF(147),NODE_DEF(148),NODE_DEF(149),
        NODE_DEF(150),NODE_DEF(151),NODE_DEF(152),NODE_DEF(153),NODE_DEF(154),NODE_DEF(155),NODE_DEF(156),NODE_DEF(157),NODE_DEF(158),NODE_DEF(159),
        NODE_DEF(160),NODE_DEF(161),NODE_DEF(162),NODE_DEF(163),NODE_DEF(164),NODE_DEF(165),NODE_DEF(166),NODE_DEF(167),NODE_DEF(168),NODE_DEF(169),
        NODE_DEF(170),NODE_DEF(171),NODE_DEF(172),NODE_DEF(173),NODE_DEF(174),NODE_DEF(175),NODE_DEF(176),NODE_DEF(177),NODE_DEF(178),NODE_DEF(179),
        NODE_DEF(180),NODE_DEF(181),NODE_DEF(182),NODE_DEF(183),NODE_DEF(184),NODE_DEF(185),NODE_DEF(186),NODE_DEF(187),NODE_DEF(188),NODE_DEF(189),
        NODE_DEF(190),NODE_DEF(191),NODE_DEF(192),NODE_DEF(193),NODE_DEF(194),NODE_DEF(195),NODE_DEF(196),NODE_DEF(197),NODE_DEF(198),NODE_DEF(199),
        NODE_DEF(200),NODE_DEF(201),NODE_DEF(202),NODE_DEF(203),NODE_DEF(204),NODE_DEF(205),NODE_DEF(206),NODE_DEF(207),NODE_DEF(208),NODE_DEF(209),
        NODE_DEF(210),NODE_DEF(211),NODE_DEF(212),NODE_DEF(213),NODE_DEF(214),NODE_DEF(215),NODE_DEF(216),NODE_DEF(217),NODE_DEF(218),NODE_DEF(219),
        NODE_DEF(220),NODE_DEF(221),NODE_DEF(222),NODE_DEF(223),NODE_DEF(224),NODE_DEF(225),NODE_DEF(226),NODE_DEF(227),NODE_DEF(228),NODE_DEF(229),
        NODE_DEF(230),NODE_DEF(231),NODE_DEF(232),NODE_DEF(233),NODE_DEF(234),NODE_DEF(235),NODE_DEF(236),NODE_DEF(237),NODE_DEF(238),NODE_DEF(239),
        NODE_DEF(240),NODE_DEF(241),NODE_DEF(242),NODE_DEF(243),NODE_DEF(244),NODE_DEF(245),NODE_DEF(246),NODE_DEF(247),NODE_DEF(248),NODE_DEF(249),
        NODE_DEF(250),NODE_DEF(251),NODE_DEF(252),NODE_DEF(253),NODE_DEF(254),NODE_DEF(255),NODE_DEF(256),NODE_DEF(257),NODE_DEF(258),NODE_DEF(259),
        NODE_DEF(260),NODE_DEF(261),NODE_DEF(262),NODE_DEF(263),NODE_DEF(264),NODE_DEF(265),NODE_DEF(266),NODE_DEF(267),NODE_DEF(268),NODE_DEF(269),
        NODE_DEF(270),NODE_DEF(271),NODE_DEF(272),NODE_DEF(273),NODE_DEF(274),NODE_DEF(275),NODE_DEF(276),NODE_DEF(277),NODE_DEF(278),NODE_DEF(279),
        NODE_DEF(280),NODE_DEF(281),NODE_DEF(282),NODE_DEF(283),NODE_DEF(284),NODE_DEF(285),NODE_DEF(286),NODE_DEF(287),NODE_DEF(288),NODE_DEF(289),
        NODE_DEF(290),NODE_DEF(291),NODE_DEF(292),NODE_DEF(293),NODE_DEF(294),NODE_DEF(295),NODE_DEF(296),NODE_DEF(297),NODE_DEF(298),NODE_DEF(299)
#endif
    }


    /*************************************
     *
     *  Enumerated values for Node types
     *  in the simulation
     *
     *      DSS - Discrete Sound Source
     *      DST - Discrete Sound Transform
     *      DSD - Discrete Sound Device
     *      DSO - Discrete Sound Output
     *
     *************************************/

    enum discrete_node_type
    {
        DSS_NULL,           /* Nothing, nill, zippo, only to be used as terminating node */
        DSS_NOP,            /* just do nothing, placeholder for potential DISCRETE_REPLACE in parent block */

        /* standard node */

        DSS_NODE,           /* a standard node */

        /* Custom */
        DST_CUSTOM,         /* whatever you want */

        /* Debugging */
        DSO_CSVLOG,         /* Dump nodes as csv file */
        DSO_WAVLOG,     /* Dump nodes as wav file */

        /* Parallel execution */
        DSO_TASK_START, /* start of parallel task */
        DSO_TASK_END,   /* end of parallel task */

        /* Output Node -- this must be the last entry in this enum! */
        DSO_OUTPUT,         /* The final output node */

        /* Import another blocklist */
        DSO_IMPORT,         /* import from another discrete block */
        DSO_REPLACE,        /* replace next node */
        DSO_DELETE,         /* delete nodes */

        /* Marks end of this enum -- must be last entry ! */
        DSO_LAST
    }


    public static class discrete_global
    {
        /*************************************
         *
         *  Core constants
         *
         *************************************/

        public const int DISCRETE_MAX_NODES = 299;  //300;
        public const int DISCRETE_MAX_INPUTS = 10;
        public const int DISCRETE_MAX_OUTPUTS = 8;

        public const int DISCRETE_MAX_TASK_GROUPS = 10;


        /*************************************
         *
         *  macros
         *  see also: emu\machine\rescap.h
         *
         *************************************/

        // moved to discrete_base_node
        /* calculate charge exponent using discrete sample time */
        //define RC_CHARGE_EXP(rc)                       (1.0 - exp(-this->sample_time() / (rc)))

        /* calculate charge exponent using given sample time */
        //define RC_CHARGE_EXP_DT(rc, dt)                (1.0 - exp(-(dt) / (rc)))
        //define RC_CHARGE_NEG_EXP_DT(rc, dt)            (1.0 - exp((dt) / (rc)))

        /* calculate discharge exponent using discrete sample time */
        //define RC_DISCHARGE_EXP(rc)                    (exp(-this->sample_time() / (rc)))
        /* calculate discharge exponent using given sample time */
        //define RC_DISCHARGE_EXP_DT(rc, dt)             (exp(-(dt) / (rc)))
        //define RC_DISCHARGE_NEG_EXP_DT(rc, dt)         (exp((dt) / (rc)))

        //define FREQ_OF_555(_r1, _r2, _c)   (1.49 / ((_r1 + 2 * _r2) * _c))


        /*************************************
         *
         *  Interface & Naming
         *
         *************************************/

        //#define DISCRETE_CLASS_FUNC(_class, _func)      DISCRETE_CLASS_NAME(_class) :: _func

        //#define DISCRETE_STEP(_class)                   void DISCRETE_CLASS_FUNC(_class, step)(void)
        //#define DISCRETE_RESET(_class)                  void DISCRETE_CLASS_FUNC(_class, reset)(void)
        //#define DISCRETE_START(_class)                  void DISCRETE_CLASS_FUNC(_class, start)(void)
        //#define DISCRETE_STOP(_class)                   void DISCRETE_CLASS_FUNC(_class, stop)(void)
        //#define DISCRETE_DECLARE_INFO(_name)            const _name *info = (const  _name *)this->custom_data();


        /*************************************
         *
         *  Node-specific constants
         *
         *************************************/

        //#define DEFAULT_TTL_V_LOGIC_1               3.4

        //#define DISC_LOGADJ                         1.0
        //#define DISC_LINADJ                         0.0

        /* DISCRETE_COMP_ADDER types */
        //#define DISC_COMP_P_CAPACITOR               0x00
        //#define DISC_COMP_P_RESISTOR                0x01

        /* clk types */
        //#define DISC_CLK_MASK                       0x03
        //#define DISC_CLK_ON_F_EDGE                  0x00
        //#define DISC_CLK_ON_R_EDGE                  0x01
        //#define DISC_CLK_BY_COUNT                   0x02
        public const int DISC_CLK_IS_FREQ                    = 0x03;

        //#define DISC_COUNT_DOWN                     0
        //#define DISC_COUNT_UP                       1

        //#define DISC_COUNTER_IS_7492                0x08

        //#define DISC_OUT_MASK                       0x30
        //#define DISC_OUT_DEFAULT                    0x00
        //#define DISC_OUT_IS_ENERGY                  0x10
        //#define DISC_OUT_HAS_XTIME                  0x20

        /* Function possibilities for the LFSR feedback nodes */
        /* 2 inputs, one output                               */
        //#define DISC_LFSR_XOR                       0
        //#define DISC_LFSR_OR                        1
        //#define DISC_LFSR_AND                       2
        //#define DISC_LFSR_XNOR                      3
        //#define DISC_LFSR_NOR                       4
        //#define DISC_LFSR_NAND                      5
        public const int DISC_LFSR_IN0                       = 6;
        //#define DISC_LFSR_IN1                       7
        //#define DISC_LFSR_NOT_IN0                   8
        //#define DISC_LFSR_NOT_IN1                   9
        public const int DISC_LFSR_REPLACE                   = 10;
        //#define DISC_LFSR_XOR_INV_IN0               11
        public const int DISC_LFSR_XOR_INV_IN1               = 12;

        /* LFSR Flag Bits */
        //#define DISC_LFSR_FLAG_OUT_INVERT           0x01
        //#define DISC_LFSR_FLAG_RESET_TYPE_L         0x00
        //#define DISC_LFSR_FLAG_RESET_TYPE_H         0x02
        public const int DISC_LFSR_FLAG_OUTPUT_F0            = 0x04;
        //#define DISC_LFSR_FLAG_OUTPUT_SR_SN1        0x08

        /* Sample & Hold supported clock types */
        //#define DISC_SAMPHOLD_REDGE                 0
        //#define DISC_SAMPHOLD_FEDGE                 1
        //#define DISC_SAMPHOLD_HLATCH                2
        //#define DISC_SAMPHOLD_LLATCH                3

        /* Shift options */
        //#define DISC_LOGIC_SHIFT__RESET_L           0x00
        //#define DISC_LOGIC_SHIFT__RESET_H           0x10
        //#define DISC_LOGIC_SHIFT__LEFT              0x00
        //#define DISC_LOGIC_SHIFT__RIGHT             0x20

        /* Maximum number of resistors in ladder chain */
        public const int DISC_LADDER_MAXRES = 8;

        /* Filter types */
        public const int DISC_FILTER_LOWPASS  = 0;
        public const int DISC_FILTER_HIGHPASS = 1;
        public const int DISC_FILTER_BANDPASS = 2;

        /* Mixer types */
        public const int DISC_MIXER_IS_RESISTOR       = 0;
        public const int DISC_MIXER_IS_OP_AMP         = 1;
        public const int DISC_MIXER_IS_OP_AMP_WITH_RI = 2;   /* Used only internally.  Use DISC_MIXER_IS_OP_AMP */


        public static readonly NODE NODE_SPECIAL = NODE_GET(DISCRETE_MAX_NODES);

        public const NODE NODE_START = NODE.NODE_00;
        public static readonly NODE NODE_END = NODE_SPECIAL;

        const NODE NODE_NC = NODE.NODE_00;


        /* Some Pre-defined nodes for convenience */

        public static NODE NODE_GET(int x) { return NODE.NODE_00 + x * DISCRETE_MAX_OUTPUTS; }
        //#define NODE_SUB(_x, _y) ((_x) + (_y))

        //#if DISCRETE_MAX_OUTPUTS == 8
        public static int NODE_CHILD_NODE_NUM(NODE x) { return (int)x & 7; }
        public static int NODE_DEFAULT_NODE(NODE x) { return (int)x & ~7; }
        public static int NODE_INDEX(NODE x) { return ((int)x - (int)NODE_START) >> 3; }
        //#else
        //#error "DISCRETE_MAX_OUTPUTS != 8"
        //#endif

        public static NODE NODE_RELATIVE(NODE x, int y) { return NODE_GET(NODE_INDEX(x) + y); }

        public static bool IS_VALUE_A_NODE(int val) { return val > (int)NODE_START && val <= (int)NODE_END; }

        // Optional node such as used in CR_FILTER
        //#define OPT_NODE(val)   (int) val
        static int OPT_NODE(double val) { return (int)val; }


        /* Common Op Amp Flags and values */
        public const int DISC_OP_AMP_IS_NORTON = 0x100;
        public const double OP_AMP_NORTON_VBE = 0.5;     // This is the norton junction voltage. Used only internally.
        public const double OP_AMP_VP_RAIL_OFFSET = 1.5;     // This is how close an op-amp can get to the vP rail. Used only internally.

        /* Integrate options */
        //#define DISC_INTEGRATE_OP_AMP_1             0x00
        //#define DISC_INTEGRATE_OP_AMP_2             0x10

        /* op amp 1 shot types */
        //#define DISC_OP_AMP_1SHT_1                  0x00

        /* Op Amp Filter Options */
        public const int DISC_OP_AMP_FILTER_IS_LOW_PASS_1   = 0x00;
        public const int DISC_OP_AMP_FILTER_IS_HIGH_PASS_1  = 0x10;
        public const int DISC_OP_AMP_FILTER_IS_BAND_PASS_1  = 0x20;
        public const int DISC_OP_AMP_FILTER_IS_BAND_PASS_1M = 0x30;
        public const int DISC_OP_AMP_FILTER_IS_HIGH_PASS_0  = 0x40;
        public const int DISC_OP_AMP_FILTER_IS_BAND_PASS_0  = 0x50;
        public const int DISC_OP_AMP_FILTER_IS_LOW_PASS_1_A = 0x60;

        public const int DISC_OP_AMP_FILTER_TYPE_MASK = 0xf0 | DISC_OP_AMP_IS_NORTON;  // Used only internally.

        /* Sallen-Key filter Opions */
        //#define DISC_SALLEN_KEY_LOW_PASS            0x01
        //#define DISC_SALLEN_KEY_HIGH_PASS           0x02


        /* Op Amp Oscillator Flags */
        //#define DISC_OP_AMP_OSCILLATOR_TYPE_MASK    (0xf0 | DISC_OP_AMP_IS_NORTON)  // Used only internally.
        //#define DISC_OP_AMP_OSCILLATOR_1            0x00
        //#define DISC_OP_AMP_OSCILLATOR_2            0x10
        //#define DISC_OP_AMP_OSCILLATOR_VCO_1        0x20
        //#define DISC_OP_AMP_OSCILLATOR_VCO_2        0x30
        //#define DISC_OP_AMP_OSCILLATOR_VCO_3        0x40

        //#define DISC_OP_AMP_OSCILLATOR_OUT_MASK         0x07
        //#define DISC_OP_AMP_OSCILLATOR_OUT_CAP          0x00
        //#define DISC_OP_AMP_OSCILLATOR_OUT_SQW          0x01
        //#define DISC_OP_AMP_OSCILLATOR_OUT_ENERGY       0x02
        //#define DISC_OP_AMP_OSCILLATOR_OUT_LOGIC_X      0x03
        //#define DISC_OP_AMP_OSCILLATOR_OUT_COUNT_F_X    0x04
        //#define DISC_OP_AMP_OSCILLATOR_OUT_COUNT_R_X    0x05

        /* Schmitt Oscillator Options */
        //#define DISC_SCHMITT_OSC_IN_IS_LOGIC        0x00
        //#define DISC_SCHMITT_OSC_IN_IS_VOLTAGE      0x01

        //#define DISC_SCHMITT_OSC_ENAB_IS_AND        0x00
        //#define DISC_SCHMITT_OSC_ENAB_IS_NAND       0x02
        //#define DISC_SCHMITT_OSC_ENAB_IS_OR         0x04
        //#define DISC_SCHMITT_OSC_ENAB_IS_NOR        0x06

        //#define DISC_SCHMITT_OSC_ENAB_MASK          0x06    /* Bits that define output enable type. */
                                                              /* Used only internally in module. */

        /* 555 Common output flags */
        public const int DISC_555_OUT_DC                     = 0x00;
        //#define DISC_555_OUT_AC                     0x10

        //#define DISC_555_TRIGGER_IS_LOGIC           0x00
        //#define DISC_555_TRIGGER_IS_VOLTAGE         0x20
        //#define DISC_555_TRIGGER_IS_COUNT           0x40
        //#define DSD_555_TRIGGER_TYPE_MASK           0x60
        //#define DISC_555_TRIGGER_DISCHARGES_CAP     0x80

        //#define DISC_555_OUT_SQW                    0x00    /* Squarewave */
        public const int DISC_555_OUT_CAP                    = 0x01;    /* Cap charge waveform */
        //#define DISC_555_OUT_COUNT_F                0x02    /* Falling count */
        //#define DISC_555_OUT_COUNT_R                0x03    /* Rising count */
        public const int DISC_555_OUT_ENERGY                 = 0x04;
        //#define DISC_555_OUT_LOGIC_X                0x05
        //#define DISC_555_OUT_COUNT_F_X              0x06
        //#define DISC_555_OUT_COUNT_R_X              0x07

        //#define DISC_555_OUT_MASK                   0x07    /* Bits that define output type. */
                                                              /* Used only internally in module. */

        //#define DISC_555_ASTABLE_HAS_FAST_CHARGE_DIODE      0x80
        //#define DISCRETE_555_CC_TO_DISCHARGE_PIN            0x00
        //#define DISCRETE_555_CC_TO_CAP                      0x80

        /* 566 output flags */
        //#define DISC_566_OUT_DC                     0x00
        //#define DISC_566_OUT_AC                     0x10

        //#define DISC_566_OUT_SQUARE                 0x00    /* Squarewave */
        //#define DISC_566_OUT_ENERGY                 0x01    /* anti-alaised Squarewave */
        //#define DISC_566_OUT_TRIANGLE               0x02    /* Triangle waveform */
        //#define DISC_566_OUT_LOGIC                  0x03    /* 0/1 logic output */
        //#define DISC_566_OUT_COUNT_F                0x04
        //#define DISC_566_OUT_COUNT_R                0x05
        //#define DISC_566_OUT_COUNT_F_X              0x06
        //#define DISC_566_OUT_COUNT_R_X              0x07
        //#define DISC_566_OUT_MASK                   0x07    /* Bits that define output type. */
                                                              /* Used only internally in module. */

        /* LS624 output flags */
        //#define DISC_LS624_OUT_SQUARE               0x01
        //#define DISC_LS624_OUT_ENERGY               0x02
        //#define DISC_LS624_OUT_LOGIC                0x03
        //#define DISC_LS624_OUT_LOGIC_X              0x04
        //#define DISC_LS624_OUT_COUNT_F              0x05
        //#define DISC_LS624_OUT_COUNT_R              0x06
        //#define DISC_LS624_OUT_COUNT_F_X            0x07
        //#define DISC_LS624_OUT_COUNT_R_X            0x08

        /* Oneshot types */
        //#define DISC_ONESHOT_FEDGE                  0x00
        //#define DISC_ONESHOT_REDGE                  0x01

        //#define DISC_ONESHOT_NORETRIG               0x00
        //#define DISC_ONESHOT_RETRIG                 0x02

        //#define DISC_OUT_ACTIVE_LOW                 0x04
        //#define DISC_OUT_ACTIVE_HIGH                0x00

        //#define DISC_CD4066_THRESHOLD               2.75

        /* Integrate */

        //#define DISC_RC_INTEGRATE_TYPE1             0x00
        //#define DISC_RC_INTEGRATE_TYPE2             0x01
        //#define DISC_RC_INTEGRATE_TYPE3             0x02


        public const int DEFAULT_555_CHARGE      = -1;
        const int DEFAULT_555_HIGH        = -1;
        public const int DEFAULT_555_VALUES_1      = DEFAULT_555_CHARGE;
        public const int DEFAULT_555_VALUES_2      = DEFAULT_555_HIGH;


        //**************************************************************************
        //  INTERFACE CONFIGURATION MACROS
        //**************************************************************************

        public static void MCFG_DISCRETE_INTF(device_t device, discrete_block [] intf) { ((discrete_device)device).set_intf(intf); }  //downcast<discrete_device &>(*device).set_intf(_intf);


        /*************************************
         *
         *  Encapsulation macros for defining
         *  your simulation
         *
         *************************************/

        //template <class C> discrete_base_node *discrete_create_node(discrete_device * pdev, const discrete_block *block) { return discrete_node_factory< C >().Create(pdev, block); }
        static discrete_base_node discrete_create_node<class_type>(discrete_device pdev, discrete_block block) where class_type : discrete_base_node, new() { return new discrete_node_factory<class_type>().Create(pdev, block); }

        //#define DISCRETE_SOUND_EXTERN(name) extern const discrete_block name[]
        //#define DISCRETE_SOUND_START(name) const discrete_block name[] = {
        //#define DSC_SND_ENTRY(_nod, _class, _dss, _num, _iact, _iinit, _custom, _name) { _nod,  new discrete_node_factory< DISCRETE_CLASS_NAME(_class) >, _dss, _num, _iact, _iinit, _custom, _name, # _class }
        public static discrete_block DSC_SND_ENTRY<class_type>(int node, int dss, int num, int [] iact, ListPointer<double> iinit, Object custom, string name) where class_type : discrete_base_node, new()
        { return new discrete_block(node, discrete_create_node<class_type>, dss, num, iact, iinit, custom, name, typeof(class_type).FullName); } // _nod,  &discrete_create_node< DISCRETE_CLASS_NAME(_class) >, _dss, _num, _iact, _iinit, _custom, _name, /* # _class*/ }; }

        public static discrete_block DISCRETE_SOUND_END() { return DSC_SND_ENTRY<discrete_special_node>( (int)NODE.NODE_00, (int)discrete_node_type.DSS_NULL     , 0, DSE_i( NODE_NC ), DSE_d( 0 ) ,null  ,"DISCRETE_SOUND_END" ); }

        static int [] ArrayCombineInt(params object [] objects)
        {
            List<int> output = new List<int>();
            for (int i = 0; i < objects.Length; i++)
            {
                if (objects[i] is NODE)
                {
                    output.Add((int)objects[i]);
                }
                else if (objects[i] is int)
                {
                    output.Add((int)objects[i]);
                }
            }

            return output.ToArray();
        }

        static ListPointer<double> ArrayCombineDouble(params object [] objects)
        {
            ListBase<double> output = new ListBase<double>();
            for (int i = 0; i < objects.Length; i++)
            {
                if (objects[i] is NODE)
                {
                    output.Add((int)objects[i]);
                }
                else if (objects[i] is int)
                {
                    output.Add((int)objects[i]);
                }
                else if (objects[i] is double)
                {
                    output.Add((double)objects[i]);
                }
            }

            return new ListPointer<double>(output);
        }

        static int [] DSE_i(params object [] objects) { return ArrayCombineInt(objects); }  //#define DSE( ... ) { __VA_ARGS__ }
        static ListPointer<double> DSE_d(params object [] objects) { return ArrayCombineDouble(objects); }  //#define DSE( ... ) { __VA_ARGS__ }

        /*      Module Name                                                       out,  enum value,      #in,   {variable inputs},              {static inputs},    data pointer,   "name" */

        /* from disc_inp.inc */
        //#define DISCRETE_ADJUSTMENT(NODE,MIN,MAX,LOGLIN,TAG)                    DSC_SND_ENTRY( NODE, dss_adjustment  , DSS_NODE        , 6, DSE( NODE_NC,NODE_NC,NODE_NC,NODE_NC,NODE_NC,NODE_NC ), DSE( MIN,MAX,LOGLIN,0   ,0   ,100  ), TAG   , "DISCRETE_ADJUSTMENT" ),
        //#define DISCRETE_ADJUSTMENTX(NODE,MIN,MAX,LOGLIN,TAG,PMIN,PMAX)         DSC_SND_ENTRY( NODE, dss_adjustment  , DSS_NODE        , 6, DSE( NODE_NC,NODE_NC,NODE_NC,NODE_NC,NODE_NC,NODE_NC ), DSE( MIN,MAX,LOGLIN,0   ,PMIN,PMAX ), TAG   , "DISCRETE_ADJUSTMENTX"  ),
        //#define DISCRETE_CONSTANT(NODE,CONST)                                   DSC_SND_ENTRY( NODE, dss_constant    , DSS_NODE        , 1, DSE( NODE_NC ), DSE( CONST ) ,NULL  ,"DISCRETE_CONSTANT" ),
        public static discrete_block DISCRETE_INPUT_DATA(NODE node) { return DSC_SND_ENTRY<discrete_dss_input_data_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 3, DSE_i( NODE_NC,NODE_NC,NODE_NC ), DSE_d( 1,0,0 ), null, "DISCRETE_INPUT_DATA" ); }
        public static discrete_block DISCRETE_INPUTX_DATA(NODE node, double GAIN, double OFFSET, double INIT) { return DSC_SND_ENTRY<discrete_dss_input_data_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 3, DSE_i( NODE_NC,NODE_NC,NODE_NC ), DSE_d( GAIN,OFFSET,INIT ), null, "DISCRETE_INPUTX_DATA" ); }
        public static discrete_block DISCRETE_INPUT_LOGIC(NODE node) { return DSC_SND_ENTRY<discrete_dss_input_logic_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 3, DSE_i( NODE_NC,NODE_NC,NODE_NC ), DSE_d( 1,0,0 ), null, "DISCRETE_INPUT_LOGIC" ); }
        //#define DISCRETE_INPUTX_LOGIC(NODE,GAIN,OFFSET,INIT)                    DSC_SND_ENTRY( NODE, dss_input_logic , DSS_NODE        , 3, DSE( NODE_NC,NODE_NC,NODE_NC ), DSE( GAIN,OFFSET,INIT ), NULL, "DISCRETE_INPUTX_LOGIC" ),
        //#define DISCRETE_INPUT_NOT(NODE)                                        DSC_SND_ENTRY( NODE, dss_input_not   , DSS_NODE        , 3, DSE( NODE_NC,NODE_NC,NODE_NC ), DSE( 1,0,0 ), NULL, "DISCRETE_INPUT_NOT" ),
        //#define DISCRETE_INPUTX_NOT(NODE,GAIN,OFFSET,INIT)                      DSC_SND_ENTRY( NODE, dss_input_not   , DSS_NODE        , 3, DSE( NODE_NC,NODE_NC,NODE_NC ), DSE( GAIN,OFFSET,INIT ), NULL, "DISCRETE_INPUTX_NOT" ),
        //#define DISCRETE_INPUT_PULSE(NODE,INIT)                                 DSC_SND_ENTRY( NODE, dss_input_pulse , DSS_NODE        , 3, DSE( NODE_NC,NODE_NC,NODE_NC ), DSE( 1,0,INIT ), NULL, "DISCRETE_INPUT_PULSE" ),

        //#define DISCRETE_INPUT_STREAM(NODE, NUM)                                DSC_SND_ENTRY( NODE, dss_input_stream, DSS_NODE        , 3, DSE( NUM,NODE_NC,NODE_NC ), DSE( NUM,1,0 ), NULL, "DISCRETE_INPUT_STREAM" ),
        public static discrete_block DISCRETE_INPUTX_STREAM(NODE node, int NUM, double GAIN, int OFFSET) { return DSC_SND_ENTRY<discrete_dss_input_stream_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 3, DSE_i( NUM,NODE_NC,NODE_NC ), DSE_d( NUM,GAIN,OFFSET ), null, "DISCRETE_INPUTX_STREAM" ); }

        //#define DISCRETE_INPUT_BUFFER(NODE, NUM)                                DSC_SND_ENTRY( NODE, dss_input_buffer, DSS_NODE        , 3, DSE( NUM,NODE_NC,NODE_NC ), DSE( NUM,1,0 ), NULL, "DISCRETE_INPUT_BUFFER" ),

        /* from disc_wav.inc */
        /* generic modules */
        //#define DISCRETE_COUNTER(NODE,ENAB,RESET,CLK,MIN,MAX,DIR,INIT0,CLKTYPE) DSC_SND_ENTRY( NODE, dss_counter     , DSS_NODE        , 8, DSE( ENAB,RESET,CLK,NODE_NC,NODE_NC,DIR,INIT0,NODE_NC ), DSE( ENAB,RESET,CLK,MIN,MAX,DIR,INIT0,CLKTYPE ), NULL, "DISCRETE_COUNTER" ),
        //#define DISCRETE_COUNTER_7492(NODE,ENAB,RESET,CLK,CLKTYPE)              DSC_SND_ENTRY( NODE, dss_counter     , DSS_NODE        , 8, DSE( ENAB,RESET,CLK,NODE_NC,NODE_NC,NODE_NC,NODE_NC,NODE_NC ), DSE( ENAB,RESET,CLK,CLKTYPE,0,1,0,DISC_COUNTER_IS_7492 ), NULL, "DISCRETE_COUNTER_7492" ),
        public static discrete_block DISCRETE_LFSR_NOISE(NODE node, int ENAB, int RESET, int CLK, double AMPL, int FEED, double BIAS, discrete_lfsr_desc LFSRTB) { return DSC_SND_ENTRY<discrete_dss_lfsr_noise_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 6, DSE_i( ENAB,RESET,CLK,AMPL,FEED,BIAS ), DSE_d( ENAB,RESET,CLK,AMPL,FEED,BIAS ), LFSRTB, "DISCRETE_LFSR_NOISE" ); }
        //#define DISCRETE_NOISE(NODE,ENAB,FREQ,AMPL,BIAS)                        DSC_SND_ENTRY( NODE, dss_noise       , DSS_NODE        , 4, DSE( ENAB,FREQ,AMPL,BIAS ), DSE( ENAB,FREQ,AMPL,BIAS ), NULL, "DISCRETE_NOISE" ),
        public static discrete_block DISCRETE_NOTE(NODE node, int ENAB, int CLK, NODE DATA, int MAX1, int MAX2, int CLKTYPE) { return DSC_SND_ENTRY<discrete_dss_note_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 6, DSE_i( ENAB,CLK,DATA,NODE_NC,NODE_NC,NODE_NC ), DSE_d( ENAB,CLK,DATA,MAX1,MAX2,CLKTYPE ), null, "DISCRETE_NOTE" ); }
        //#define DISCRETE_SAWTOOTHWAVE(NODE,ENAB,FREQ,AMPL,BIAS,GRAD,PHASE)      DSC_SND_ENTRY( NODE, dss_sawtoothwave, DSS_NODE        , 6, DSE( ENAB,FREQ,AMPL,BIAS,NODE_NC,NODE_NC ), DSE( ENAB,FREQ,AMPL,BIAS,GRAD,PHASE ), NULL, "DISCRETE_SAWTOOTHWAVE" ),
        //#define DISCRETE_SINEWAVE(NODE,ENAB,FREQ,AMPL,BIAS,PHASE)               DSC_SND_ENTRY( NODE, dss_sinewave    , DSS_NODE        , 5, DSE( ENAB,FREQ,AMPL,BIAS,NODE_NC ), DSE( ENAB,FREQ,AMPL,BIAS,PHASE ), NULL, "DISCRETE_SINEWAVE" ),
        //#define DISCRETE_SQUAREWAVE(NODE,ENAB,FREQ,AMPL,DUTY,BIAS,PHASE)        DSC_SND_ENTRY( NODE, dss_squarewave  , DSS_NODE        , 6, DSE( ENAB,FREQ,AMPL,DUTY,BIAS,NODE_NC ), DSE( ENAB,FREQ,AMPL,DUTY,BIAS,PHASE ), NULL, "DISCRETE_SQUAREWAVE" ),
        public static discrete_block DISCRETE_SQUAREWFIX(NODE node, int ENAB, int FREQ, double AMPL, int DUTY, double BIAS, double PHASE) { return DSC_SND_ENTRY<discrete_dss_squarewfix_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 6, DSE_i( ENAB,FREQ,AMPL,DUTY,BIAS,NODE_NC ), DSE_d( ENAB,FREQ,AMPL,DUTY,BIAS,PHASE ), null, "DISCRETE_SQUAREWFIX" ); }
        //#define DISCRETE_SQUAREWAVE2(NODE,ENAB,AMPL,T_OFF,T_ON,BIAS,TSHIFT)     DSC_SND_ENTRY( NODE, dss_squarewave2 , DSS_NODE        , 6, DSE( ENAB,AMPL,T_OFF,T_ON,BIAS,NODE_NC ), DSE( ENAB,AMPL,T_OFF,T_ON,BIAS,TSHIFT ), NULL, "DISCRETE_SQUAREWAVE2" ),
        //#define DISCRETE_TRIANGLEWAVE(NODE,ENAB,FREQ,AMPL,BIAS,PHASE)           DSC_SND_ENTRY( NODE, dss_trianglewave, DSS_NODE        , 5, DSE( ENAB,FREQ,AMPL,BIAS,NODE_NC ), DSE( ENAB,FREQ,AMPL,BIAS,PHASE ), NULL, "DISCRETE_TRIANGLEWAVE" ),
        /* Component specific */
        //#define DISCRETE_INVERTER_OSC(NODE,ENAB,MOD,RCHARGE,RP,C,R2,INFO)       DSC_SND_ENTRY( NODE, dss_inverter_osc, DSS_NODE        , 6, DSE( ENAB,MOD,NODE_NC,NODE_NC,NODE_NC,NODE_NC ), DSE( ENAB,MOD,RCHARGE,RP,C,R2 ), INFO, "DISCRETE_INVERTER_OSC" ),
        //#define DISCRETE_OP_AMP_OSCILLATOR(NODE,ENAB,INFO)                      DSC_SND_ENTRY( NODE, dss_op_amp_osc  , DSS_NODE        , 1, DSE( ENAB ), DSE( ENAB ), INFO, "DISCRETE_OP_AMP_OSCILLATOR" ),
        //#define DISCRETE_OP_AMP_VCO1(NODE,ENAB,VMOD1,INFO)                      DSC_SND_ENTRY( NODE, dss_op_amp_osc  , DSS_NODE        , 2, DSE( ENAB,VMOD1 ), DSE( ENAB,VMOD1 ), INFO, "DISCRETE_OP_AMP_VCO1" ),
        //#define DISCRETE_OP_AMP_VCO2(NODE,ENAB,VMOD1,VMOD2,INFO)                DSC_SND_ENTRY( NODE, dss_op_amp_osc  , DSS_NODE        , 3, DSE( ENAB,VMOD1,VMOD2 ), DSE( ENAB,VMOD1,VMOD2 ), INFO, "DISCRETE_OP_AMP_VCO2" ),
        //#define DISCRETE_SCHMITT_OSCILLATOR(NODE,ENAB,INP0,AMPL,TABLE)          DSC_SND_ENTRY( NODE, dss_schmitt_osc , DSS_NODE        , 3, DSE( ENAB,INP0,AMPL ), DSE( ENAB,INP0,AMPL ), TABLE, "DISCRETE_SCHMITT_OSCILLATOR" ),
        /* Not yet implemented */
        //#define DISCRETE_ADSR_ENV(NODE,ENAB,TRIGGER,GAIN,ADSRTB)                DSC_SND_ENTRY( NODE, dss_adsr        , DSS_NODE        , 3, DSE( ENAB,TRIGGER,GAIN ), DSE( ENAB,TRIGGER,GAIN ), ADSRTB, "DISCRETE_ADSR_ENV" ),

        /* from disc_mth.inc */
        /* generic modules */
        //#define DISCRETE_ADDER2(NODE,ENAB,INP0,INP1)                            DSC_SND_ENTRY( NODE, dst_adder       , DSS_NODE        , 3, DSE( ENAB,INP0,INP1 ), DSE( ENAB,INP0,INP1 ), NULL, "DISCRETE_ADDER2" ),
        //#define DISCRETE_ADDER3(NODE,ENAB,INP0,INP1,INP2)                       DSC_SND_ENTRY( NODE, dst_adder       , DSS_NODE        , 4, DSE( ENAB,INP0,INP1,INP2 ), DSE( ENAB,INP0,INP1,INP2 ), NULL, "DISCRETE_ADDER3" ),
        //#define DISCRETE_ADDER4(NODE,ENAB,INP0,INP1,INP2,INP3)                  DSC_SND_ENTRY( NODE, dst_adder       , DSS_NODE        , 5, DSE( ENAB,INP0,INP1,INP2,INP3 ), DSE( ENAB,INP0,INP1,INP2,INP3 ), NULL, "DISCRETE_ADDER4" ),
        public static discrete_block DISCRETE_CLAMP(NODE node, NODE INP0, double MIN, double MAX) { return DSC_SND_ENTRY<discrete_dst_clamp_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 3, DSE_i( INP0,MIN,MAX ), DSE_d( INP0,MIN,MAX ), null, "DISCRETE_CLAMP" ); }
        //#define DISCRETE_DIVIDE(NODE,ENAB,INP0,INP1)                            DSC_SND_ENTRY( NODE, dst_divide      , DSS_NODE        , 3, DSE( ENAB,INP0,INP1 ), DSE( ENAB,INP0,INP1 ), NULL, "DISCRETE_DIVIDE" ),
        //#define DISCRETE_GAIN(NODE,INP0,GAIN)                                   DSC_SND_ENTRY( NODE, dst_gain        , DSS_NODE        , 3, DSE( INP0,NODE_NC,NODE_NC ), DSE( INP0,GAIN,0 ), NULL, "DISCRETE_GAIN" ),
        //#define DISCRETE_INVERT(NODE,INP0)                                      DSC_SND_ENTRY( NODE, dst_gain        , DSS_NODE        , 3, DSE( INP0,NODE_NC,NODE_NC ), DSE( INP0,-1,0 ), NULL, "DISCRETE_INVERT" ),
        public static discrete_block DISCRETE_LOGIC_INVERT(NODE node, NODE INP0) {return DSC_SND_ENTRY<discrete_dst_logic_inv_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 1, DSE_i( INP0 ), DSE_d( INP0 ), null, "DISCRETE_LOGIC_INVERT" ); }

        //#define DISCRETE_BIT_DECODE(NODE, INP, BIT_N, VOUT)                     DSC_SND_ENTRY( NODE, dst_bits_decode , DSS_NODE        , 4, DSE( INP,NODE_NC,NODE_NC,NODE_NC ), DSE( INP,BIT_N,BIT_N,VOUT ), NULL, "DISCRETE_BIT_DECODE" ),
        public static discrete_block DISCRETE_BITS_DECODE(NODE node, NODE INP, int BIT_FROM, int BIT_TO, double VOUT) { return DSC_SND_ENTRY<discrete_dst_bits_decode_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 4, DSE_i( INP,NODE_NC,NODE_NC,NODE_NC ), DSE_d( INP,BIT_FROM,BIT_TO,VOUT ), null, "DISCRETE_BITS_DECODE" ); }

        //#define DISCRETE_LOGIC_AND(NODE,INP0,INP1)                              DSC_SND_ENTRY( NODE, dst_logic_and   , DSS_NODE        , 4, DSE( INP0,INP1,NODE_NC,NODE_NC ), DSE( INP0,INP1,1.0,1.0 ), NULL, "DISCRETE_LOGIC_AND" ),
        //#define DISCRETE_LOGIC_AND3(NODE,INP0,INP1,INP2)                        DSC_SND_ENTRY( NODE, dst_logic_and   , DSS_NODE        , 4, DSE( INP0,INP1,INP2,NODE_NC ), DSE( INP0,INP1,INP2,1.0 ), NULL, "DISCRETE_LOGIC_AND3" ),
        //#define DISCRETE_LOGIC_AND4(NODE,INP0,INP1,INP2,INP3)                   DSC_SND_ENTRY( NODE, dst_logic_and   , DSS_NODE        , 4, DSE( INP0,INP1,INP2,INP3 ), DSE( INP0,INP1,INP2,INP3 ) ,NULL, "DISCRETE_LOGIC_AND4" ),
        //#define DISCRETE_LOGIC_NAND(NODE,INP0,INP1)                             DSC_SND_ENTRY( NODE, dst_logic_nand  , DSS_NODE        , 4, DSE( INP0,INP1,NODE_NC,NODE_NC ), DSE( INP0,INP1,1.0,1.0 ), NULL, "DISCRETE_LOGIC_NAND" ),
        //#define DISCRETE_LOGIC_NAND3(NODE,INP0,INP1,INP2)                       DSC_SND_ENTRY( NODE, dst_logic_nand  , DSS_NODE        , 4, DSE( INP0,INP1,INP2,NODE_NC ), DSE( INP0,INP1,INP2,1.0 ), NULL, "DISCRETE_LOGIC_NAND3" ),
        //#define DISCRETE_LOGIC_NAND4(NODE,INP0,INP1,INP2,INP3)                  DSC_SND_ENTRY( NODE, dst_logic_nand  , DSS_NODE        , 4, DSE( INP0,INP1,INP2,INP3 ), DSE( INP0,INP1,INP2,INP3 ), NULL, ")DISCRETE_LOGIC_NAND4" ),
        //#define DISCRETE_LOGIC_OR(NODE,INP0,INP1)                               DSC_SND_ENTRY( NODE, dst_logic_or    , DSS_NODE        , 4, DSE( INP0,INP1,NODE_NC,NODE_NC ), DSE( INP0,INP1,0.0,0.0 ), NULL, "DISCRETE_LOGIC_OR" ),
        //#define DISCRETE_LOGIC_OR3(NODE,INP0,INP1,INP2)                         DSC_SND_ENTRY( NODE, dst_logic_or    , DSS_NODE        , 4, DSE( INP0,INP1,INP2,NODE_NC ), DSE( INP0,INP1,INP2,0.0 ), NULL, "DISCRETE_LOGIC_OR3" ),
        //#define DISCRETE_LOGIC_OR4(NODE,INP0,INP1,INP2,INP3)                    DSC_SND_ENTRY( NODE, dst_logic_or    , DSS_NODE        , 4, DSE( INP0,INP1,INP2,INP3 ), DSE( INP0,INP1,INP2,INP3 ), NULL, "DISCRETE_LOGIC_OR4" ),
        //#define DISCRETE_LOGIC_NOR(NODE,INP0,INP1)                              DSC_SND_ENTRY( NODE, dst_logic_nor   , DSS_NODE        , 4, DSE( INP0,INP1,NODE_NC,NODE_NC ), DSE( INP0,INP1,0.0,0.0 ), NULL, "DISCRETE_LOGIC_NOR" ),
        //#define DISCRETE_LOGIC_NOR3(NODE,INP0,INP1,INP2)                        DSC_SND_ENTRY( NODE, dst_logic_nor   , DSS_NODE        , 4, DSE( INP0,INP1,INP2,NODE_NC ), DSE( INP0,INP1,INP2,0.0 ), NULL, "DISCRETE_LOGIC_NOR3" ),
        //#define DISCRETE_LOGIC_NOR4(NODE,INP0,INP1,INP2,INP3)                   DSC_SND_ENTRY( NODE, dst_logic_nor   , DSS_NODE        , 4, DSE( INP0,INP1,INP2,INP3 ), DSE( INP0,INP1,INP2,INP3 ), NULL, "DISCRETE_LOGIC_NOR4" ),
        //#define DISCRETE_LOGIC_XOR(NODE,INP0,INP1)                              DSC_SND_ENTRY( NODE, dst_logic_xor   , DSS_NODE        , 2, DSE( INP0,INP1 ), DSE( INP0,INP1 ), NULL, "DISCRETE_LOGIC_XOR" ),
        //#define DISCRETE_LOGIC_XNOR(NODE,INP0,INP1)                             DSC_SND_ENTRY( NODE, dst_logic_nxor  , DSS_NODE        , 2, DSE( INP0,INP1 ), DSE( INP0,INP1 ), NULL, "DISCRETE_LOGIC_XNOR" ),
        public static discrete_block DISCRETE_LOGIC_DFLIPFLOP(NODE node, int RESET, int SET, NODE CLK, NODE INP) { return DSC_SND_ENTRY<discrete_dst_logic_dff_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 4, DSE_i( RESET,SET,CLK,INP ), DSE_d( RESET,SET,CLK,INP ), null, "DISCRETE_LOGIC_DFLIPFLOP" ); }
        //#define DISCRETE_LOGIC_JKFLIPFLOP(NODE,RESET,SET,CLK,J,K)               DSC_SND_ENTRY( NODE, dst_logic_jkff  , DSS_NODE        , 5, DSE( RESET,SET,CLK,J,K ), DSE( RESET,SET,CLK,J,K ), NULL, "DISCRETE_LOGIC_JKFLIPFLOP" ),
        //#define DISCRETE_LOGIC_SHIFT(NODE,INP0,RESET,CLK,SIZE,OPTIONS)          DSC_SND_ENTRY( NODE, dst_logic_shift , DSS_NODE        , 5, DSE( INP0,RESET,CLK,NODE_NC,NODE_NC ), DSE( INP0,RESET,CLK,SIZE,OPTIONS ), NULL, "DISCRETE_LOGIC_SHIFT" ),
        //#define DISCRETE_LOOKUP_TABLE(NODE,ADDR,SIZE,TABLE)                     DSC_SND_ENTRY( NODE, dst_lookup_table, DSS_NODE        , 2, DSE( ADDR,NODE_NC ), DSE( ADDR,SIZE ), TABLE, "DISCRETE_LOOKUP_TABLE" ),
        //#define DISCRETE_MULTIPLEX2(NODE,ADDR,INP0,INP1)                        DSC_SND_ENTRY( NODE, dst_multiplex   , DSS_NODE        , 3, DSE( ADDR,INP0,INP1 ), DSE( ADDR,INP0,INP1 ), NULL, "DISCRETE_MULTIPLEX2" ),
        //#define DISCRETE_MULTIPLEX4(NODE,ADDR,INP0,INP1,INP2,INP3)              DSC_SND_ENTRY( NODE, dst_multiplex   , DSS_NODE        , 5, DSE( ADDR,INP0,INP1,INP2,INP3 ), DSE( ADDR,INP0,INP1,INP2,INP3 ), NULL, "DISCRETE_MULTIPLEX4" ),
        //#define DISCRETE_MULTIPLEX8(NODE,ADDR,INP0,INP1,INP2,INP3,INP4,INP5,INP6,INP7) DSC_SND_ENTRY( NODE, dst_multiplex, DSS_NODE    , 9, DSE( ADDR,INP0,INP1,INP2,INP3,INP4,INP5,INP6,INP7 ), DSE( ADDR,INP0,INP1,INP2,INP3,INP4,INP5,INP6,INP7 ), NULL, "DISCRETE_MULTIPLEX8" ),
        public static discrete_block DISCRETE_MULTIPLY(NODE node, double INP0, NODE INP1) { return DSC_SND_ENTRY<discrete_dst_gain_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 3, DSE_i( INP0,INP1,NODE_NC ), DSE_d( INP0,INP1,0 ), null, "DISCRETE_MULTIPLY" ); }
        public static discrete_block DISCRETE_MULTADD(NODE node, NODE INP0, double INP1, double INP2) { return DSC_SND_ENTRY<discrete_dst_gain_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 3, DSE_i( INP0,INP1,INP2 ), DSE_d( INP0,INP1,INP2 ), null, "DISCRETE_MULTADD" ); }
        //#define DISCRETE_ONESHOT(NODE,TRIG,AMPL,WIDTH,TYPE)                     DSC_SND_ENTRY( NODE, dst_oneshot     , DSS_NODE        , 5, DSE( 0,TRIG,AMPL,WIDTH,NODE_NC ), DSE( 0,TRIG,AMPL,WIDTH,TYPE ), NULL, "DISCRETE_ONESHOT" ),
        //#define DISCRETE_ONESHOTR(NODE,RESET,TRIG,AMPL,WIDTH,TYPE)              DSC_SND_ENTRY( NODE, dst_oneshot     , DSS_NODE        , 5, DSE( RESET,TRIG,AMPL,WIDTH,NODE_NC ), DSE( RESET,TRIG,AMPL,WIDTH,TYPE ), NULL, "One Shot Resetable" ),
        //#define DISCRETE_ONOFF(NODE,ENAB,INP0)                                  DSC_SND_ENTRY( NODE, dst_gain        , DSS_NODE        , 3, DSE( ENAB,INP0,NODE_NC ), DSE( 0,1,0 ), NULL, "DISCRETE_ONOFF" ),
        //#define DISCRETE_RAMP(NODE,ENAB,RAMP,GRAD,START,END,CLAMP)              DSC_SND_ENTRY( NODE, dst_ramp        , DSS_NODE        , 6, DSE( ENAB,RAMP,GRAD,START,END,CLAMP ), DSE( ENAB,RAMP,GRAD,START,END,CLAMP ), NULL, "DISCRETE_RAMP" ),
        //#define DISCRETE_SAMPLHOLD(NODE,INP0,CLOCK,CLKTYPE)                     DSC_SND_ENTRY( NODE, dst_samphold    , DSS_NODE        , 3, DSE( INP0,CLOCK,NODE_NC ), DSE( INP0,CLOCK,CLKTYPE ), NULL, "DISCRETE_SAMPLHOLD" ),
        //#define DISCRETE_SWITCH(NODE,ENAB,SWITCH,INP0,INP1)                     DSC_SND_ENTRY( NODE, dst_switch      , DSS_NODE        , 4, DSE( ENAB,SWITCH,INP0,INP1 ), DSE( ENAB,SWITCH,INP0,INP1 ), NULL, "DISCRETE_SWITCH" ),
        //#define DISCRETE_ASWITCH(NODE,CTRL,INP,THRESHOLD)                       DSC_SND_ENTRY( NODE, dst_aswitch     , DSS_NODE        , 3, DSE( CTRL,INP,THRESHOLD ), DSE( CTRL,INP, THRESHOLD), NULL, "Analog Switch" ),
        //#define DISCRETE_TRANSFORM2(NODE,INP0,INP1,FUNCT)                       DSC_SND_ENTRY( NODE, dst_transform   , DSS_NODE        , 2, DSE( INP0,INP1 ), DSE( INP0,INP1 ), FUNCT, "DISCRETE_TRANSFORM2" ),
        //#define DISCRETE_TRANSFORM3(NODE,INP0,INP1,INP2,FUNCT)                  DSC_SND_ENTRY( NODE, dst_transform   , DSS_NODE        , 3, DSE( INP0,INP1,INP2 ), DSE( INP0,INP1,INP2 ), FUNCT, "DISCRETE_TRANSFORM3" ),
        //#define DISCRETE_TRANSFORM4(NODE,INP0,INP1,INP2,INP3,FUNCT)             DSC_SND_ENTRY( NODE, dst_transform   , DSS_NODE        , 4, DSE( INP0,INP1,INP2,INP3 ), DSE( INP0,INP1,INP2,INP3 ), FUNCT, "DISCRETE_TRANSFORM4" ),
        public static discrete_block DISCRETE_TRANSFORM5(NODE node, NODE INP0, double INP1, double INP2, NODE INP3, double INP4, string FUNCT) {return DSC_SND_ENTRY<discrete_dst_transform_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 5, DSE_i( INP0,INP1,INP2,INP3,INP4 ), DSE_d( INP0,INP1,INP2,INP3,INP4 ), FUNCT, "DISCRETE_TRANSFORM5" ); }
        /* Component specific */
        //#define DISCRETE_COMP_ADDER(NODE,DATA,TABLE)                            DSC_SND_ENTRY( NODE, dst_comp_adder  , DSS_NODE        , 1, DSE( DATA ), DSE( DATA ), TABLE, "DISCRETE_COMP_ADDER" ),
        public static discrete_block DISCRETE_DAC_R1(NODE node, NODE DATA, double VDATA, discrete_dac_r1_ladder LADDER) { return DSC_SND_ENTRY<discrete_dst_dac_r1_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 2, DSE_i( DATA,NODE_NC ), DSE_d( DATA,VDATA ), LADDER, "DISCRETE_DAC_R1" ); }
        //#define DISCRETE_DIODE_MIXER2(NODE,IN0,IN1,TABLE)                       DSC_SND_ENTRY( NODE, dst_diode_mix   , DSS_NODE        , 2, DSE( IN0,IN1 ), DSE( IN0,IN1 ), TABLE, "DISCRETE_DIODE_MIXER2" ),
        //#define DISCRETE_DIODE_MIXER3(NODE,IN0,IN1,IN2,TABLE)                   DSC_SND_ENTRY( NODE, dst_diode_mix   , DSS_NODE        , 3, DSE( IN0,IN1,IN2 ), DSE( IN0,IN1,IN2 ), TABLE, "DISCRETE_DIODE_MIXER3" ),
        //#define DISCRETE_DIODE_MIXER4(NODE,IN0,IN1,IN2,IN3,TABLE)               DSC_SND_ENTRY( NODE, dst_diode_mix   , DSS_NODE        , 4, DSE( IN0,IN1,IN2,IN3 ), DSE( IN0,IN1,IN2,IN3 ), TABLE, "DISCRETE_DIODE_MIXER4" ),
        //#define DISCRETE_INTEGRATE(NODE,TRG0,TRG1,INFO)                         DSC_SND_ENTRY( NODE, dst_integrate   , DSS_NODE        , 2, DSE( TRG0,TRG1 ), DSE( TRG0,TRG1 ), INFO, "DISCRETE_INTEGRATE" ),
        //#define DISCRETE_MIXER2(NODE,ENAB,IN0,IN1,INFO)                         DSC_SND_ENTRY( NODE, dst_mixer       , DSS_NODE        , 3, DSE( ENAB,IN0,IN1 ), DSE( ENAB,IN0,IN1 ), INFO, "DISCRETE_MIXER2" ),
        public static discrete_block DISCRETE_MIXER3(NODE node, int ENAB, NODE IN0, NODE IN1, NODE IN2, discrete_mixer_desc INFO) { return DSC_SND_ENTRY<discrete_dst_mixer_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 4, DSE_i( ENAB,IN0,IN1,IN2 ), DSE_d( ENAB,IN0,IN1,IN2 ), INFO, "DISCRETE_MIXER3" ); }
        //#define DISCRETE_MIXER4(NODE,ENAB,IN0,IN1,IN2,IN3,INFO)                 DSC_SND_ENTRY( NODE, dst_mixer       , DSS_NODE        , 5, DSE( ENAB,IN0,IN1,IN2,IN3 ), DSE( ENAB,IN0,IN1,IN2,IN3 ), INFO, "DISCRETE_MIXER4" ),
        public static discrete_block DISCRETE_MIXER5(NODE node, int ENAB, NODE IN0, NODE IN1, NODE IN2, NODE IN3, NODE IN4, discrete_mixer_desc INFO) { return DSC_SND_ENTRY<discrete_dst_mixer_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 6, DSE_i( ENAB,IN0,IN1,IN2,IN3,IN4 ), DSE_d( ENAB,IN0,IN1,IN2,IN3,IN4 ), INFO, "DISCRETE_MIXER5" ); }
        public static discrete_block DISCRETE_MIXER6(NODE node, int ENAB, NODE IN0, NODE IN1, NODE IN2, NODE IN3, NODE IN4, NODE IN5, discrete_mixer_desc INFO) { return DSC_SND_ENTRY<discrete_dst_mixer_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 7, DSE_i( ENAB,IN0,IN1,IN2,IN3,IN4,IN5 ), DSE_d( ENAB,IN0,IN1,IN2,IN3,IN4,IN5 ), INFO, "DISCRETE_MIXER6" ); }
        //#define DISCRETE_MIXER7(NODE,ENAB,IN0,IN1,IN2,IN3,IN4,IN5,IN6,INFO)     DSC_SND_ENTRY( NODE, dst_mixer       , DSS_NODE        , 8, DSE( ENAB,IN0,IN1,IN2,IN3,IN4,IN5,IN6 ), DSE( ENAB,IN0,IN1,IN2,IN3,IN4,IN5,IN6 ), INFO, "DISCRETE_MIXER7" ),
        //#define DISCRETE_MIXER8(NODE,ENAB,IN0,IN1,IN2,IN3,IN4,IN5,IN6,IN7,INFO) DSC_SND_ENTRY( NODE, dst_mixer       , DSS_NODE        , 9, DSE( ENAB,IN0,IN1,IN2,IN3,IN4,IN5,IN6,IN7 ), DSE( ENAB,IN0,IN1,IN2,IN3,IN4,IN5,IN6,IN7 ), INFO, "DISCRETE_MIXER8" ),
        //#define DISCRETE_OP_AMP(NODE,ENAB,IN0,IN1,INFO)                         DSC_SND_ENTRY( NODE, dst_op_amp      , DSS_NODE        , 3, DSE( ENAB,IN0,IN1 ), DSE( ENAB,IN0,IN1 ), INFO, "DISCRETE_OP_AMP" ),
        //#define DISCRETE_OP_AMP_ONESHOT(NODE,TRIG,INFO)                         DSC_SND_ENTRY( NODE, dst_op_amp_1sht , DSS_NODE        , 1, DSE( TRIG ), DSE( TRIG ), INFO, "DISCRETE_OP_AMP_ONESHOT" ),
        //#define DISCRETE_OP_AMP_TRIG_VCA(NODE,TRG0,TRG1,TRG2,IN0,IN1,INFO)      DSC_SND_ENTRY( NODE, dst_tvca_op_amp , DSS_NODE        , 5, DSE( TRG0,TRG1,TRG2,IN0,IN1 ), DSE( TRG0,TRG1,TRG2,IN0,IN1 ), INFO, "DISCRETE_OP_AMP_TRIG_VCA" ),
        //#define DISCRETE_VCA(NODE,ENAB,IN0,CTRL,TYPE)                           DSC_SND_ENTRY( NODE, dst_vca         , DSS_NODE        , 4, DSE( ENAB,IN0,CTRL,NODE_NC ), DSE( ENAB,IN0,CTRL,TYPE ), NULL, "DISCRETE_VCA" ),
        //#define DISCRETE_XTIME_BUFFER(NODE,IN0,LOW,HIGH)                        DSC_SND_ENTRY( NODE, dst_xtime_buffer, DSS_NODE        , 4, DSE( IN0,LOW,HIGH,NODE_NC ), DSE( IN0,LOW,HIGH,0 ), NULL, "DISCRETE_XTIME_BUFFER" ),
        //#define DISCRETE_XTIME_INVERTER(NODE,IN0,LOW,HIGH)                      DSC_SND_ENTRY( NODE, dst_xtime_buffer, DSS_NODE        , 4, DSE( IN0,LOW,HIGH,NODE_NC ), DSE( IN0,LOW,HIGH,1 ), NULL, "DISCRETE_XTIME_INVERTER" ),
        //#define DISCRETE_XTIME_AND(NODE,IN0,IN1,LOW,HIGH)                       DSC_SND_ENTRY( NODE, dst_xtime_and   , DSS_NODE        , 5, DSE( IN0,IN1,LOW,HIGH,NODE_NC ), DSE( IN0,IN1,LOW,HIGH,0 ), NULL, "DISCRETE_XTIME_AND" ),
        //#define DISCRETE_XTIME_NAND(NODE,IN0,IN1,LOW,HIGH)                      DSC_SND_ENTRY( NODE, dst_xtime_and   , DSS_NODE        , 5, DSE( IN0,IN1,LOW,HIGH,NODE_NC ), DSE( IN0,IN1,LOW,HIGH,1 ), NULL, "DISCRETE_XTIME_NAND" ),
        //#define DISCRETE_XTIME_OR(NODE,IN0,IN1,LOW,HIGH)                        DSC_SND_ENTRY( NODE, dst_xtime_or    , DSS_NODE        , 5, DSE( IN0,IN1,LOW,HIGH,NODE_NC ), DSE( IN0,IN1,LOW,HIGH,0 ), NULL, "DISCRETE_XTIME_OR" ),
        //#define DISCRETE_XTIME_NOR(NODE,IN0,IN1,LOW,HIGH)                       DSC_SND_ENTRY( NODE, dst_xtime_or    , DSS_NODE        , 5, DSE( IN0,IN1,LOW,HIGH,NODE_NC ), DSE( IN0,IN1,LOW,HIGH,1 ), NULL, "DISCRETE_XTIME_NOR" ),
        //#define DISCRETE_XTIME_XOR(NODE,IN0,IN1,LOW,HIGH)                       DSC_SND_ENTRY( NODE, dst_xtime_xor   , DSS_NODE        , 5, DSE( IN0,IN1,LOW,HIGH,NODE_NC ), DSE( IN0,IN1,LOW,HIGH,0 ), NULL, "DISCRETE_XTIME_XOR" ),
        //#define DISCRETE_XTIME_XNOR(NODE,IN0,IN1,LOW,HIGH)                      DSC_SND_ENTRY( NODE, dst_xtime_xnor  , DSS_NODE        , 5, DSE( IN0,IN1,LOW,HIGH,NODE_NC ), DSE( IN0,IN1,LOW,HIGH,1 ), NULL, "DISCRETE_XTIME_XNOR" ),

        /* from disc_flt.inc */
        /* generic modules */
        //#define DISCRETE_FILTER1(NODE,ENAB,INP0,FREQ,TYPE)                      DSC_SND_ENTRY( NODE, dst_filter1     , DSS_NODE        , 4, DSE( ENAB,INP0,NODE_NC,NODE_NC ), DSE( ENAB,INP0,FREQ,TYPE ), NULL, "DISCRETE_FILTER1" ),
        //#define DISCRETE_FILTER2(NODE,ENAB,INP0,FREQ,DAMP,TYPE)                 DSC_SND_ENTRY( NODE, dst_filter2     , DSS_NODE        , 5, DSE( ENAB,INP0,NODE_NC,NODE_NC,NODE_NC ), DSE( ENAB,INP0,FREQ,DAMP,TYPE ), NULL, "DISCRETE_FILTER2" ),
        /* Component specific */
        //#define DISCRETE_SALLEN_KEY_FILTER(NODE,ENAB,INP0,TYPE,INFO)            DSC_SND_ENTRY( NODE, dst_sallen_key  , DSS_NODE        , 3, DSE( ENAB,INP0,NODE_NC ), DSE( ENAB,INP0,TYPE ), INFO, "DISCRETE_SALLEN_KEY_FILTER" ),
        public static discrete_block DISCRETE_CRFILTER(NODE node, NODE INP0, double RVAL, double CVAL) { return DSC_SND_ENTRY<discrete_dst_crfilter_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 3, DSE_i( INP0,OPT_NODE(RVAL),OPT_NODE(CVAL) ), DSE_d( INP0,RVAL,CVAL ), null, "DISCRETE_CRFILTER" ); }
        //#define DISCRETE_CRFILTER_VREF(NODE,INP0,RVAL,CVAL,VREF)                DSC_SND_ENTRY( NODE, dst_crfilter    , DSS_NODE        , 4, DSE( INP0,OPT_NODE(RVAL),OPT_NODE(CVAL),VREF ), DSE( INP0,RVAL,CVAL,VREF ), NULL, "DISCRETE_CRFILTER_VREF" ),
        public static discrete_block DISCRETE_OP_AMP_FILTER(NODE node, int ENAB, NODE INP0, int INP1, int TYPE, discrete_op_amp_filt_info INFO) { return DSC_SND_ENTRY<discrete_dst_op_amp_filt_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 4, DSE_i( ENAB,INP0,INP1,NODE_NC ), DSE_d( ENAB,INP0,INP1,TYPE ), INFO, "DISCRETE_OP_AMP_FILTER" ); }
        //#define DISCRETE_RC_CIRCUIT_1(NODE,INP0,INP1,RVAL,CVAL)                 DSC_SND_ENTRY( NODE, dst_rc_circuit_1, DSS_NODE        , 4, DSE( INP0,INP1,NODE_NC,NODE_NC ), DSE( INP0,INP1,RVAL,CVAL ), NULL, "DISCRETE_RC_CIRCUIT_1" ),
        //#define DISCRETE_RCDISC(NODE,ENAB,INP0,RVAL,CVAL)                       DSC_SND_ENTRY( NODE, dst_rcdisc      , DSS_NODE        , 4, DSE( ENAB,INP0,NODE_NC,NODE_NC ), DSE( ENAB,INP0,RVAL,CVAL ), NULL, "DISCRETE_RCDISC" ),
        //#define DISCRETE_RCDISC2(NODE,SWITCH,INP0,RVAL0,INP1,RVAL1,CVAL)        DSC_SND_ENTRY( NODE, dst_rcdisc2     , DSS_NODE        , 6, DSE( SWITCH,INP0,NODE_NC,INP1,NODE_NC,NODE_NC ), DSE( SWITCH,INP0,RVAL0,INP1,RVAL1,CVAL ), NULL, "DISCRETE_RCDISC2" ),
        //#define DISCRETE_RCDISC3(NODE,ENAB,INP0,RVAL0,RVAL1,CVAL,DJV)           DSC_SND_ENTRY( NODE, dst_rcdisc3     , DSS_NODE        , 6, DSE( ENAB,INP0,NODE_NC,NODE_NC,NODE_NC,NODE_NC ), DSE( ENAB,INP0,RVAL0,RVAL1,CVAL,DJV ), NULL, "DISCRETE_RCDISC3" ),
        //#define DISCRETE_RCDISC4(NODE,ENAB,INP0,RVAL0,RVAL1,RVAL2,CVAL,VP,TYPE) DSC_SND_ENTRY( NODE, dst_rcdisc4     , DSS_NODE        , 8, DSE( ENAB,INP0,NODE_NC,NODE_NC,NODE_NC,NODE_NC,NODE_NC,NODE_NC ), DSE( ENAB,INP0,RVAL0,RVAL1,RVAL2,CVAL,VP,TYPE ), NULL, "DISCRETE_RCDISC4" ),
        public static discrete_block DISCRETE_RCDISC5(NODE node, NODE ENAB, NODE INP0, double RVAL, double CVAL) { return DSC_SND_ENTRY<discrete_dst_rcdisc5_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 4, DSE_i( ENAB,INP0,NODE_NC,NODE_NC ), DSE_d( ENAB,INP0,RVAL,CVAL ), null, "DISCRETE_RCDISC5" ); }
        //#define DISCRETE_RCDISC_MODULATED(NODE,INP0,INP1,RVAL0,RVAL1,RVAL2,RVAL3,CVAL,VP)   DSC_SND_ENTRY( NODE, dst_rcdisc_mod, DSS_NODE        , 8, DSE( INP0,INP1,NODE_NC,NODE_NC,NODE_NC,NODE_NC,NODE_NC,NODE_NC ), DSE( INP0,INP1,RVAL0,RVAL1,RVAL2,RVAL3,CVAL,VP ), NULL, "DISCRETE_RCDISC_MODULATED" ),
        public static discrete_block DISCRETE_RCFILTER(NODE node, NODE INP0, double RVAL, double CVAL) { return DSC_SND_ENTRY<discrete_dst_rcfilter_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 3, DSE_i( INP0,OPT_NODE(RVAL),OPT_NODE(CVAL) ), DSE_d( INP0,RVAL,CVAL ), null, "DISCRETE_RCFILTER" ); }
        //#define DISCRETE_RCFILTER_VREF(NODE,INP0,RVAL,CVAL,VREF)                DSC_SND_ENTRY( NODE, dst_rcfilter    , DSS_NODE        , 4, DSE( INP0,OPT_NODE(RVAL),OPT_NODE(CVAL),VREF ), DSE( INP0,RVAL,CVAL,VREF ), NULL, "DISCRETE_RCFILTER_VREF" ),
        public static discrete_block DISCRETE_RCFILTER_SW(NODE node, int ENAB, NODE INP0, NODE SW, int RVAL, double CVAL1, double CVAL2, int CVAL3, int CVAL4) { return DSC_SND_ENTRY<discrete_dst_rcfilter_sw_node>( (int)node, (int)discrete_node_type.DSS_NODE    , 8, DSE_i( ENAB,INP0,SW,NODE_NC,NODE_NC,NODE_NC,NODE_NC,NODE_NC ), DSE_d( ENAB,INP0,SW,RVAL,CVAL1,CVAL2,CVAL3,CVAL4 ), null, "DISCRETE_RCFILTER_SW" ); }
        //#define DISCRETE_RCINTEGRATE(NODE,INP0,RVAL0,RVAL1,RVAL2,CVAL,vP,TYPE)  DSC_SND_ENTRY( NODE, dst_rcintegrate , DSS_NODE        , 7, DSE( INP0,NODE_NC,NODE_NC,NODE_NC,NODE_NC,NODE_NC,NODE_NC ), DSE( INP0,RVAL0,RVAL1,RVAL2,CVAL,vP,TYPE ), NULL, "DISCRETE_RCINTEGRATE" ),
        /* For testing - seem to be buggered.  Use versions not ending in N. */
        //#define DISCRETE_RCDISCN(NODE,ENAB,INP0,RVAL,CVAL)                      DSC_SND_ENTRY( NODE, dst_rcdiscn     , DSS_NODE        , 4, DSE( ENAB,INP0,NODE_NC,NODE_NC ), DSE( ENAB,INP0,RVAL,CVAL ), NULL, "DISCRETE_RCDISCN" ),
        //#define DISCRETE_RCDISC2N(NODE,SWITCH,INP0,RVAL0,INP1,RVAL1,CVAL)       DSC_SND_ENTRY( NODE, dst_rcdisc2n    , DSS_NODE        , 6, DSE( SWITCH,INP0,NODE_NC,INP1,NODE_NC,NODE_NC ), DSE( SWITCH,INP0,RVAL0,INP1,RVAL1,CVAL ), NULL, "DISCRETE_RCDISC2N" ),
        //#define DISCRETE_RCFILTERN(NODE,ENAB,INP0,RVAL,CVAL)                    DSC_SND_ENTRY( NODE, dst_rcfiltern   , DSS_NODE        , 4, DSE( ENAB,INP0,NODE_NC,NODE_NC ), DSE( ENAB,INP0,RVAL,CVAL ), NULL, "DISCRETE_RCFILTERN" ),

        /* from disc_dev.inc */
        /* generic modules */
        //#define DISCRETE_CUSTOM1(NODE,CLASS,IN0,INFO)                                 DSC_SND_ENTRY( NODE, CLASS, DST_CUSTOM      , 1, DSE( IN0 ), DSE( IN0 ), INFO, "DISCRETE_CUSTOM1" ),
        //#define DISCRETE_CUSTOM2(NODE,CLASS,IN0,IN1,INFO)                             DSC_SND_ENTRY( NODE, CLASS, DST_CUSTOM      , 2, DSE( IN0,IN1 ), DSE( IN0,IN1 ), INFO, "DISCRETE_CUSTOM2" ),
        //#define DISCRETE_CUSTOM3(NODE,CLASS,IN0,IN1,IN2,INFO)                         DSC_SND_ENTRY( NODE, CLASS, DST_CUSTOM      , 3, DSE( IN0,IN1,IN2 ), DSE( IN0,IN1,IN2 ), INFO, "DISCRETE_CUSTOM3" ),
        //#define DISCRETE_CUSTOM4(NODE,CLASS,IN0,IN1,IN2,IN3,INFO)                     DSC_SND_ENTRY( NODE, CLASS, DST_CUSTOM      , 4, DSE( IN0,IN1,IN2,IN3 ), DSE( IN0,IN1,IN2,IN3 ), INFO, "DISCRETE_CUSTOM4" ),
        //#define DISCRETE_CUSTOM5(NODE,CLASS,IN0,IN1,IN2,IN3,IN4,INFO)                 DSC_SND_ENTRY( NODE, CLASS, DST_CUSTOM      , 5, DSE( IN0,IN1,IN2,IN3,IN4 ), DSE( IN0,IN1,IN2,IN3,IN4 ), INFO, "DISCRETE_CUSTOM5" ),
        //#define DISCRETE_CUSTOM6(NODE,CLASS,IN0,IN1,IN2,IN3,IN4,IN5,INFO)             DSC_SND_ENTRY( NODE, CLASS, DST_CUSTOM      , 6, DSE( IN0,IN1,IN2,IN3,IN4,IN5 ), DSE( IN0,IN1,IN2,IN3,IN4,IN5 ), INFO, "DISCRETE_CUSTOM6" ),
        //#define DISCRETE_CUSTOM7(NODE,CLASS,IN0,IN1,IN2,IN3,IN4,IN5,IN6,INFO)         DSC_SND_ENTRY( NODE, CLASS, DST_CUSTOM      , 7, DSE( IN0,IN1,IN2,IN3,IN4,IN5,IN6 ), DSE( IN0,IN1,IN2,IN3,IN4,IN5,IN6 ), INFO, "DISCRETE_CUSTOM7" ),
        //#define DISCRETE_CUSTOM8(NODE,CLASS,IN0,IN1,IN2,IN3,IN4,IN5,IN6,IN7,INFO)     DSC_SND_ENTRY( NODE, CLASS, DST_CUSTOM      , 8, DSE( IN0,IN1,IN2,IN3,IN4,IN5,IN6,IN7 ), DSE( IN0,IN1,IN2,IN3,IN4,IN5,IN6,IN7 ), INFO, "DISCRETE_CUSTOM8" ),
        //#define DISCRETE_CUSTOM9(NODE,CLASS,IN0,IN1,IN2,IN3,IN4,IN5,IN6,IN7,IN8,INFO) DSC_SND_ENTRY( NODE, CLASS, DST_CUSTOM      , 9, DSE( IN0,IN1,IN2,IN3,IN4,IN5,IN6,IN7,IN8 ), DSE( IN0,IN1,IN2,IN3,IN4,IN5,IN6,IN7,IN8 ), INFO, "DISCRETE_CUSTOM9" ),

        /* Component specific */
        //#define DISCRETE_555_ASTABLE(NODE,RESET,R1,R2,C,OPTIONS)                DSC_SND_ENTRY( NODE, dsd_555_astbl   , DSS_NODE        , 5, DSE( RESET,R1,R2,C,NODE_NC ), DSE( RESET,R1,R2,C,-1 ), OPTIONS, "DISCRETE_555_ASTABLE" ),
        public static discrete_block DISCRETE_555_ASTABLE_CV(NODE node, int RESET, double R1, double R2, double C, NODE CTRLV, discrete_555_desc OPTIONS) { return DSC_SND_ENTRY<discrete_dsd_555_astbl_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 5, DSE_i( RESET,R1,R2,C,CTRLV ), DSE_d( RESET,R1,R2,C,CTRLV ), OPTIONS, "DISCRETE_555_ASTABLE_CV" ); }
        //#define DISCRETE_555_MSTABLE(NODE,RESET,TRIG,R,C,OPTIONS)               DSC_SND_ENTRY( NODE, dsd_555_mstbl   , DSS_NODE        , 4, DSE( RESET,TRIG,R,C ), DSE( RESET,TRIG,R,C ), OPTIONS, "DISCRETE_555_MSTABLE" ),
        public static discrete_block DISCRETE_555_CC(NODE node, int RESET, NODE VIN, double R, double C, int RBIAS, int RGND, int RDIS, discrete_555_cc_desc OPTIONS) { return DSC_SND_ENTRY<discrete_dsd_555_cc_node>( (int)node, (int)discrete_node_type.DSS_NODE        , 7, DSE_i( RESET,VIN,R,C,RBIAS,RGND,RDIS ), DSE_d( RESET,VIN,R,C,RBIAS,RGND,RDIS ), OPTIONS, "DISCRETE_555_CC" ); }
        //#define DISCRETE_555_VCO1(NODE,RESET,VIN,OPTIONS)                       DSC_SND_ENTRY( NODE, dsd_555_vco1    , DSS_NODE        , 3, DSE( RESET,VIN,NODE_NC ), DSE( RESET,VIN,-1 ), OPTIONS, "DISCRETE_555_VCO1" ),
        //#define DISCRETE_555_VCO1_CV(NODE,RESET,VIN,CTRLV,OPTIONS)              DSC_SND_ENTRY( NODE, dsd_555_vco1    , DSS_NODE        , 3, DSE( RESET,VIN,CTRLV ), DSE( RESET,VIN,CTRLV ), OPTIONS, "DISCRETE_555_VCO1_CV" ),
        //#define DISCRETE_566(NODE,VMOD,R,C,VPOS,VNEG,VCHARGE,OPTIONS)           DSC_SND_ENTRY( NODE, dsd_566         , DSS_NODE        , 7, DSE( VMOD,R,C,NODE_NC,NODE_NC,VCHARGE,NODE_NC ), DSE( VMOD,R,C,VPOS,VNEG,VCHARGE,OPTIONS ), NULL, "DISCRETE_566" ),
        //#define DISCRETE_74LS624(NODE,ENAB,VMOD,VRNG,C,R_FREQ_IN,C_FREQ_IN,R_RNG_IN,OUTTYPE) DSC_SND_ENTRY( NODE, dsd_ls624   , DSS_NODE        , 8, DSE( ENAB,VMOD,NODE_NC,NODE_NC,NODE_NC,NODE_NC,NODE_NC,NODE_NC ), DSE( ENAB,VMOD,VRNG,C,R_FREQ_IN,C_FREQ_IN,R_RNG_IN,OUTTYPE ), NULL, "DISCRETE_74LS624" ),

        /* NOP */
        //#define DISCRETE_NOP(NODE)                                              DSC_SND_ENTRY( NODE, dss_nop         , DSS_NOP         , 0, DSE( 0 ), DSE( 0 ), NULL, "DISCRETE_NOP" ),

        /* logging */
        //#define DISCRETE_CSVLOG1(NODE1)                                         DSC_SND_ENTRY( NODE_SPECIAL, dso_csvlog  , DSO_CSVLOG  , 1, DSE( NODE1 ), DSE( NODE1 ), NULL, "DISCRETE_CSVLOG1" ),
        //#define DISCRETE_CSVLOG2(NODE1,NODE2)                                   DSC_SND_ENTRY( NODE_SPECIAL, dso_csvlog  , DSO_CSVLOG  , 2, DSE( NODE1,NODE2 ), DSE( NODE1,NODE2 ), NULL, "DISCRETE_CSVLOG2" ),
        //#define DISCRETE_CSVLOG3(NODE1,NODE2,NODE3)                             DSC_SND_ENTRY( NODE_SPECIAL, dso_csvlog  , DSO_CSVLOG  , 3, DSE( NODE1,NODE2,NODE3 ), DSE( NODE1,NODE2,NODE3 ), NULL, "DISCRETE_CSVLOG3" ),
        //#define DISCRETE_CSVLOG4(NODE1,NODE2,NODE3,NODE4)                       DSC_SND_ENTRY( NODE_SPECIAL, dso_csvlog  , DSO_CSVLOG  , 4, DSE( NODE1,NODE2,NODE3,NODE4 ), DSE( NODE1,NODE2,NODE3,NODE4 ), NULL, "DISCRETE_CSVLOG4" ),
        //#define DISCRETE_CSVLOG5(NODE1,NODE2,NODE3,NODE4,NODE5)                 DSC_SND_ENTRY( NODE_SPECIAL, dso_csvlog  , DSO_CSVLOG  , 5, DSE( NODE1,NODE2,NODE3,NODE4,NODE5 ), DSE( NODE1,NODE2,NODE3,NODE4,NODE5 ), NULL, "DISCRETE_CSVLOG5" ),
        //#define DISCRETE_WAVLOG1(NODE1,GAIN1)                                   DSC_SND_ENTRY( NODE_SPECIAL, dso_wavlog  , DSO_WAVLOG  , 2, DSE( NODE1,NODE_NC ), DSE( NODE1,GAIN1 ), NULL, "DISCRETE_WAVLOG1" ),
        //#define DISCRETE_WAVLOG2(NODE1,GAIN1,NODE2,GAIN2)                       DSC_SND_ENTRY( NODE_SPECIAL, dso_wavlog  , DSO_WAVLOG  , 4, DSE( NODE1,NODE_NC,NODE2,NODE_NC ), DSE( NODE1,GAIN1,NODE2,GAIN2 ), NULL, "DISCRETE_WAVLOG2" ),

        /* import */
        //#define DISCRETE_IMPORT(INFO)                                           DSC_SND_ENTRY( NODE_SPECIAL, special     , DSO_IMPORT  , 0, DSE( 0 ), DSE( 0 ), &(INFO), "DISCRETE_IMPORT" ),
        //#define DISCRETE_DELETE(NODE_FROM, NODE_TO)                             DSC_SND_ENTRY( NODE_SPECIAL, special     , DSO_DELETE  , 2, DSE( NODE_FROM, NODE_TO ), DSE( NODE_FROM, NODE_TO ), NULL, "DISCRETE_DELETE" ),
        //#define DISCRETE_REPLACE                                                DSC_SND_ENTRY( NODE_SPECIAL, special     , DSO_REPLACE , 0, DSE( 0 ), DSE( 0 ), NULL, "DISCRETE_REPLACE" ),

        /* parallel tasks */

        public static discrete_block DISCRETE_TASK_START(double TASK_GROUP) { return DSC_SND_ENTRY<discrete_special_node>( (int)NODE_SPECIAL, (int)discrete_node_type.DSO_TASK_START, 2, DSE_i( NODE_NC, NODE_NC ), DSE_d( TASK_GROUP, 0 ), null, "DISCRETE_TASK_START" ); }
        public static discrete_block DISCRETE_TASK_END() { return DSC_SND_ENTRY<discrete_special_node>( (int)NODE_SPECIAL, (int)discrete_node_type.DSO_TASK_END  , 0, DSE_i( 0 ), DSE_d( 0 ), null, "DISCRETE_TASK_END" ); }
        //#define DISCRETE_TASK_SYNC()                                          DSC_SND_ENTRY( NODE_SPECIAL, special     , DSO_TASK_SYNC , 0, DSE( 0 ), DSE( 0 ), NULL, "DISCRETE_TASK_SYNC" ),

        /* output */
        public static discrete_block DISCRETE_OUTPUT(NODE OPNODE, double GAIN) { return DSC_SND_ENTRY<discrete_dso_output_node>( (int)NODE_SPECIAL, (int)discrete_node_type.DSO_OUTPUT   ,2, DSE_i( OPNODE,NODE_NC ), DSE_d( 0,GAIN ), null, "DISCRETE_OUTPUT" ); }


        /*************************************
         *
         *  Performance
         *
         *************************************/

        /*
         * Normally, the discrete core processes 960 samples per update.
         * With the various buffers involved, this on a Core2 is not as
         * performant as processing 240 samples 4 times.
         * The setting most probably depends on CPU and which modules are
         * run and how many tasks are defined.
         *
         * Values < 32 exhibit poor performance (too much overhead) while
         * Values > 500 have a slightly worse performace (too much cache misses?).
         */

        public const int MAX_SAMPLES_PER_TASK_SLICE = 960 / 4;

        /*************************************
         *
         *  Debugging
         *
         *************************************/

        public const int DISCRETE_DEBUGLOG = 0;

        /*************************************
         *
         *  Use tasks ?
         *
         *************************************/

        public const int USE_DISCRETE_TASKS = 1;
    }


    /*************************************
        *
        *  Classes and structs to handle
        *  linked lists.
        *
        *************************************/

    //#define for_each(_T, _e, _l) for (_T _e = (_l)->begin_ptr() ;  _e <= (_l)->end_ptr(); _e++)

    /*
    * add and delete may be slow - the focus is on access!
    */

        // TODO: replace with dynamic_array from utils
    //template<class _ElementType> struct dynamic_array_t
    public class vector_t<_ElementType>
    {
        //_ElementType    *m_arr;
        //int m_count;
        //int m_allocated;
        protected List<_ElementType> m_buffer = new List<_ElementType>();


        public vector_t(int initial)
        {
            //m_count = 0;
            //m_allocated = initial;
            //m_arr = global_alloc_array_clear(_ElementType, m_allocated);
            m_buffer = new List<_ElementType>(initial);
        }
        public vector_t()
        {
            //m_count = 0;
            //m_allocated = 16;
            //m_arr = global_alloc_array_clear(_ElementType, m_allocated);
        }
        ~vector_t()
        {
            //global_free_array(m_arr);
        }

        //_ElementType& operator [] (unsigned int index) const { return m_arr[index]; }  // get array item
        public _ElementType this[int index] { get { return m_buffer[index]; } set { m_buffer[index] = value; } }
        public _ElementType this[UInt32 index] { get { return m_buffer[(int)index]; } set { m_buffer[(int)index] = value; } }

#if false
        dynamic_array_t(const dynamic_array_t &a)  // copy constructor
        {
            m_allocated = a.count();
            if (m_allocated < 16)
                m_allocated = 16;
            m_count = a.count();
            m_arr = global_alloc_array_clear(_ElementType, m_allocated);
            for (int i=0; i < m_count; i++)
                m_arr[i] = a[i];
        }
        dynamic_array_t& operator = (const dynamic_array_t &a) // assignment operator
        {
            if (this == &a) return *this;
            m_allocated = a.count();
            if (m_allocated < 16)
                m_allocated = 16;
            m_count = a.count();
            m_arr = global_alloc_array_clear(_ElementType, m_allocated);
            for (int i=0; i < m_count; i++)
                m_arr[i] = a[i];
            return *this;
        }
#endif

        public _ElementType add(_ElementType obj)
        {
            //if (m_count >= m_allocated)
            //{
            //    m_allocated *= 2;
            //    _ElementType *newarr = global_alloc_array_clear(_ElementType, m_allocated);
            //    for (int i=0; i < m_count; i++)
            //        newarr[i] = m_arr[i];
            //    global_free_array(m_arr);
            //    m_arr = newarr;
            //}
            //m_arr[m_count] = obj;
            //m_count++;
            //return &m_arr[m_count-1];

            m_buffer.Add(obj);
            return obj;
        }
        public void remove(int index)
        {
            //for (int i=index+1; i < m_count; i++)
            //    m_arr[i-1] = m_arr[i];
            //m_count--;

            m_buffer.RemoveAt(index);
        }
        public void clear() { m_buffer.Clear();  }
        public int count() { return m_buffer.Count; }
        //_ElementType *begin_ptr() { return m_arr; }
        //_ElementType *end_ptr() { return m_arr + (m_count - 1); }
    }


    /*************************************
     *
     *  Node-specific struct types
     *
     *************************************/

    public class discrete_lfsr_desc
    {
        int clock_type;
        int bitlength;
        int reset_value;

        int feedback_bitsel0;
        int feedback_bitsel1;
        int feedback_function0;         /* Combines bitsel0 & bitsel1 */

        int feedback_function1;         /* Combines funct0 & infeed bit */

        int feedback_function2;         /* Combines funct1 & shifted register */
        int feedback_function2_mask;    /* Which bits are affected by function 2 */

        int flags;

        int output_bit;

        public discrete_lfsr_desc(int clock_type, int bitlength, int reset_value, int feedback_bitsel0, int feedback_bitsel1, int feedback_function0, int feedback_function1, int feedback_function2, int feedback_function2_mask, int flags, int output_bit)
        { this.clock_type = clock_type; this.bitlength = bitlength; this.reset_value = reset_value; this.feedback_bitsel0 = feedback_bitsel0; this.feedback_bitsel1 = feedback_bitsel1; this.feedback_function0 = feedback_function0; this.feedback_function1 = feedback_function1; this.feedback_function2 = feedback_function2; this.feedback_function2_mask = feedback_function2_mask; this.flags = flags; this.output_bit = output_bit; }
    }


    public class discrete_dac_r1_ladder
    {
        public int ladderLength;       // 2 to DISC_LADDER_MAXRES.  1 would be useless.
        public double [] r = new double[discrete_global.DISC_LADDER_MAXRES];  // Don't use 0 for valid resistors.  That is a short.
        public double vBias;          // Voltage Bias resistor is tied to (0 = not used)
        public double rBias;          // Additional resistor tied to vBias (0 = not used)
        public double rGnd;           // Resistor tied to ground (0 = not used)
        public double cFilter;        // Filtering cap (0 = not used)

        public discrete_dac_r1_ladder(int ladderLength, double [] r, double vBias, double rBias, double rGnd, double cFilter)
        { this.ladderLength = ladderLength; Array.Copy(r, this.r, r.Length); this.vBias = vBias; this.rBias = rBias; this.rGnd = rGnd; this.cFilter = cFilter; }
    }


    public class discrete_op_amp_filt_info
    {
        public double r1;
        public double r2;
        public double r3;
        public double r4;
        public double rF;
        public double c1;
        public double c2;
        public double c3;
        public double vRef;
        public double vP;
        public double vN;

        public discrete_op_amp_filt_info(double r1, double r2, double r3, double r4, double rF, double c1, double c2, double c3, double vRef, double vP, double vN)
        { this.r1 = r1; this.r2 = r2; this.r3 = r3; this.r4 = r4; this.rF = rF; this.c1 = c1; this.c2 = c2; this.c3 = c3; this.vRef = vRef; this.vP = vP; this.vN = vN;  }
    }


    public class discrete_555_desc
    {
        int     options;    /* bit mapped options */
        double  v_pos;      /* B+ voltage of 555 */
        double  v_charge;   /* voltage to charge circuit  (Defaults to v_pos) */
        double  v_out_high; /* High output voltage of 555 (Defaults to v_pos - 1.2V) */

        public discrete_555_desc(int options, double v_pos, double v_charge, double v_out_high)
        { this.options = options; this.v_pos = v_pos; this.v_charge = v_charge; this.v_out_high = v_out_high; }
    }


    //#define DEFAULT_555_CC_SOURCE   DEFAULT_555_CHARGE

    public class discrete_555_cc_desc
    {
        int     options;        /* bit mapped options */
        double  v_pos;          /* B+ voltage of 555 */
        double  v_cc_source;    /* Voltage of the Constant Current source */
        double  v_out_high;     /* High output voltage of 555 (Defaults to v_pos - 1.2V) */
        double  v_cc_junction;  /* The voltage drop of the Constant Current source transistor (0 if Op Amp) */

        public discrete_555_cc_desc(int options, double v_pos, double v_cc_source, double v_out_high, double v_cc_junction)
        { this.options = options; this.v_pos = v_pos; this.v_cc_source = v_cc_source; this.v_out_high = v_out_high; this.v_cc_junction = v_cc_junction; }
    }

#if false
    struct discrete_555_vco1_desc
    {
        int    options;             /* bit mapped options */
        double r1, r2, r3, r4, c;
        double v_pos;               /* B+ voltage of 555 */
        double v_charge;            /* (ignored) */
        double v_out_high;          /* High output voltage of 555 (Defaults to v_pos - 1.2V) */
    }


    struct discrete_adsr
    {
        double attack_time;  /* All times are in seconds */
        double attack_value;
        double decay_time;
        double decay_value;
        double sustain_time;
        double sustain_value;
        double release_time;
        double release_value;
    }
#endif

    public class discrete_mixer_desc
    {
        const int DISC_MAX_MIXER_INPUTS = 8;

        public int type;
        public double [] r = new double[DISC_MAX_MIXER_INPUTS];       /* static input resistance values.  These are in series with rNode, if used. */
        public int [] r_node = new int[DISC_MAX_MIXER_INPUTS];  /* variable resistance nodes, if needed.  0 if not used. */
        public double [] c = new double[DISC_MAX_MIXER_INPUTS];
        public double rI;
        public double rF;
        public double cF;
        public double cAmp;
        public double vRef;
        public double gain;               /* Scale value to get output close to +/- 32767 */

        public discrete_mixer_desc(int type, double [] r, int [] r_node, double [] c, double rI, double rF, double cF, double cAmp, double vRef, double gain)
        { this.type = type; Array.Copy(r, this.r, r.Length); Array.Copy(r_node, this.r_node, r_node.Length); Array.Copy(c, this.c, c.Length); this.rI = rI; this.rF = rF; this.cF = cF; this.cAmp = cAmp; this.vRef = vRef; this.gain = gain; }
    }


    //discrete_base_node *(*factory)(discrete_device * pdev, const discrete_block *block);
    public delegate discrete_base_node discrete_block_factory(discrete_device pdev, discrete_block block);

    /*************************************
     *
     *  The discrete sound blocks as
     *  defined in the drivers
     *
     *************************************/
    public class discrete_block
    {
        public int node;                           /* Output node number */
        public discrete_block_factory factory;  //discrete_base_node *(*factory)(discrete_device * pdev, const discrete_block *block);
        public int type;                           /* see defines below */
        public int active_inputs;                  /* Number of active inputs on this node type */
        public int [] input_node = new int[discrete_global.DISCRETE_MAX_INPUTS];/* input/control nodes */
        public ListPointer<double> initial = new ListPointer<double>();  //double          initial[DISCRETE_MAX_INPUTS];   /* Initial values */
        public Object custom;  //const void *    custom;                         /* Custom function specific initialisation data */
        string name;                        /* Node Name */
        public string mod_name;                       /* Module / class name */

        public discrete_block(int node, discrete_block_factory factory, int type, int active_inputs, int [] input_node, ListPointer<double> initial, Object custom, string name, string mod_name)
        { this.node = node; this.factory = factory; this.type = type; this.active_inputs = active_inputs; Array.Copy(input_node, this.input_node, input_node.Length); this.initial = initial; this.custom = custom; this.name = name; this.mod_name = mod_name; }
    }


    /*************************************
        *
        *  Node interfaces
        *
        *************************************/

    public interface discrete_step_interface
    {
        //public osd_ticks_t run_time;
        //public discrete_base_node self;

        //~discrete_step_interface() { }

        osd_ticks_t run_time { get; set; }
        discrete_base_node self { get; set; }

        void step();
    }

    //typedef dynamic_array_t<discrete_step_interface *> node_step_list_t;


    public interface discrete_input_interface
    {
        //~discrete_input_interface() { }

        void input_write(int sub_node, byte data );
    }


    public interface discrete_sound_output_interface
    {
        //~discrete_sound_output_interface() { }

        void set_output_ptr(ListPointer<stream_sample_t> ptr);
    }


    // ======================> discrete_device
    public class discrete_device : device_t
    {
        // configuration state
        discrete_block [] m_intf;  //const discrete_block *m_intf;

        // internal state

        /* --------------------------------- */

        /* emulation info */
        protected int m_sample_rate;
        double m_sample_time;
        double m_neg_sample_time;

        /* list of all nodes */
        protected vector_t<discrete_base_node> m_node_list = new vector_t<discrete_base_node>();        /* node_description * */


        /* internal node tracking */
        discrete_base_node [] m_indexed_node;  //discrete_base_node **   m_indexed_node;

        /* tasks */
        vector_t<discrete_task> task_list = new vector_t<discrete_task>();      /* discrete_task_context * */

        /* debugging statistics */
        //FILE *                  m_disclogfile;

        /* parallel tasks */
        osd_work_queue m_queue;

        /* profiling */
        int m_profiling;
        UInt64 m_total_samples;
        UInt64 m_total_stream_updates;


        //friend class discrete_base_node;

        // construction/destruction
        public discrete_device(machine_config mconfig, device_type type, string tag, device_t owner, UInt32 clock)
            : base(mconfig, type, tag, owner, clock)
        {
            m_intf = null;
            m_sample_rate = 0;
            m_sample_time = 0;
            m_neg_sample_time = 0;
            m_indexed_node = null;

            //throw new emu_unimplemented();
#if false
            m_disclogfile = null;
#endif

            m_queue = null;
            m_profiling = 0;
            m_total_samples = 0;
            m_total_stream_updates = 0;
        }


        // inline configuration helpers

        //-------------------------------------------------
        //  static_set_intf - configuration helper to set
        //  the interface
        //-------------------------------------------------
        public void set_intf(discrete_block [] intf) { m_intf = intf; }


        //-------------------------------------------------
        //  read - read from the chip's registers and internal RAM
        //-------------------------------------------------
        public uint8_t read(offs_t offset)
        {
            discrete_base_node node = discrete_find_node((int)offset);

            byte data;

            /* Read the node input value if allowed */
            if (node != null)
            {
                /* Bring the system up to now */
                update_to_current_time();

                data = (byte)node.m_output[discrete_global.NODE_CHILD_NODE_NUM((NODE)offset)][0];
            }
            else
            {
                throw new emu_fatalerror("discrete_sound_r read from non-existent NODE_{0}\n", offset - (offs_t)NODE.NODE_00);
            }

            return data;
        }

        //-------------------------------------------------
        //  write - write to the chip's registers and internal RAM
        //-------------------------------------------------
        public void write(offs_t offset, uint8_t data)
        {
            discrete_base_node node = discrete_find_node((int)offset);

            /* Update the node input value if it's a proper input node */
            if (node != null)
            {
                discrete_input_interface intf;
                if (node.interface_get(out intf))
                    intf.input_write(0, data);
                else
                    discrete_log("discrete_sound_w write to non-input NODE_{0}\n", offset-(int)NODE.NODE_00);
            }
            else
            {
                discrete_log("discrete_sound_w write to non-existent NODE_{0}\n", offset-(int)NODE.NODE_00);
            }
        }


        /* --------------------------------- */

        public virtual void update_to_current_time() { }


        /* process a number of samples */
        //-------------------------------------------------
        //  discrete_device_process - process a number of
        //  samples.
        //
        //  input / output buffers are stream_sample_t
        //  to not to have to convert the buffers.
        //  a "discrete cpu" device will pass NULL here
        //-------------------------------------------------
        public void process(int samples)
        {
            if (samples == 0)
                return;

            /* Setup tasks */
            for (int i = 0; i < task_list.count(); i++)  //for_each(discrete_task **, task, &task_list)
            {
                discrete_task task = task_list[i];

                /* unlock the thread */
                task.unlock();

                task.prepare_for_queue(samples);
            }

            for (int i = 0; i < task_list.count(); i++)  //for_each(discrete_task **, task, &task_list)
            {
                discrete_task task = task_list[i];

                /* Fire a work item for each task */
                osdcore_global.m_osdcore.osd_work_item_queue(m_queue, discrete_task.task_callback, task_list, osdcore_interface.WORK_ITEM_FLAG_AUTO_RELEASE);
            }

            osdcore_global.m_osdcore.osd_work_queue_wait(m_queue, osdcore_global.m_osdcore.osd_ticks_per_second() * 10);

            if (m_profiling != 0)
            {
                m_total_samples += (UInt64)samples;
                m_total_stream_updates++;
            }
        }

        /* access to the discrete_logging facility */
        //-------------------------------------------------
        //  discrete_log: Debug logging
        //-------------------------------------------------
        public void discrete_log(string format, params object [] args)
        {
            if (discrete_global.DISCRETE_DEBUGLOG != 0)
            {
                throw new emu_unimplemented();
#if false
                va_list arg;
                va_start(arg, text);

                if(m_disclogfile)
                {
                    vfprintf(m_disclogfile, text, arg);
                    fprintf(m_disclogfile, "\n");
                    fflush(m_disclogfile);
                }

                va_end(arg);
#endif

                logerror(format, args);
            }
        }

        /* get pointer to a info struct node ref */
        public ListPointer<double> node_output_ptr(int onode)  // const double *discrete_device::node_output_ptr(int onode)
        {
            discrete_base_node node;
            node = discrete_find_node(onode);

            if (node != null)
            {
                return new ListPointer<double>(node.m_output[discrete_global.NODE_CHILD_NODE_NUM((NODE)onode)]);  //&(node->m_output[NODE_CHILD_NODE_NUM(onode)]);
            }
            else
            {
                return null;
            }
        }

        /* FIXME: this is used by csv and wav logs - going forward, identifiers should be explicitly passed */
        //int same_module_index(const discrete_base_node &node);

        /* get node */
        public discrete_base_node discrete_find_node(int node)
        {
            if (node < (int)discrete_global.NODE_START || node > (int)discrete_global.NODE_END)
                return null;

            return m_indexed_node[discrete_global.NODE_INDEX((NODE)node)];
        }

        /* are we profiling */
        public int profiling() { return m_profiling; }

        public int sample_rate() { return m_sample_rate; }
        public double sample_time() { return m_sample_time; }


        // device-level overrides

        //-------------------------------------------------
        //  device_start - device-specific startup
        //-------------------------------------------------
        protected override void device_start()
        {
            // create the stream
            //m_stream = machine().sound().stream_alloc(*this, 0, 2, 22257);

            discrete_block [] intf_start = m_intf;
            string name;

            /* If a clock is specified we will use it, otherwise run at the audio sample rate. */
            if (clock() != 0)
                m_sample_rate = (int)clock();
            else
                m_sample_rate = machine().sample_rate();

            m_sample_time = 1.0 / m_sample_rate;
            m_neg_sample_time = - m_sample_time;

            m_total_samples = 0;
            m_total_stream_updates = 0;

            /* create the logfile */
            name = string.Format("discrete{0}.log", tag());  //sprintf(name, "discrete%s.log", this->tag());

            //throw new emu_unimplemented();
#if false
            if (DISCRETE_DEBUGLOG)
                m_disclogfile = fopen(name, "w");
#endif

            /* enable profiling */
            m_profiling = 0;

            //throw new emu_unimplemented();
#if false
            if (getenv("DISCRETE_PROFILING"))
                m_profiling = atoi(getenv("DISCRETE_PROFILING"));
#endif

            /* Build the final block list */
            vector_t<discrete_block> block_list = new vector_t<discrete_block>();  //sound_block_list_t block_list;
            discrete_build_list(intf_start, ref block_list);

            /* first pass through the nodes: sanity check, fill in the indexed_nodes, and make a total count */
            discrete_sanity_check(block_list);

            /* Start with empty lists */
            m_node_list.clear();

            /* allocate memory to hold pointers to nodes by index */
            m_indexed_node = new discrete_base_node [discrete_global.DISCRETE_MAX_NODES];  // m_indexed_node = auto_alloc_array_clear(this->machine(), discrete_base_node *, DISCRETE_MAX_NODES);

            /* initialize the node data */
            init_nodes(block_list);

            /* now go back and find pointers to all input nodes */
            for (int i = 0; i < m_node_list.count(); i++)  //for_each(discrete_base_node **, node, &m_node_list)
            {
                discrete_base_node node = m_node_list[i];

                node.resolve_input_nodes();
            }

            /* allocate a queue */
            m_queue = osdcore_global.m_osdcore.osd_work_queue_alloc((int)(osdcore_interface.WORK_QUEUE_FLAG_MULTI | osdcore_interface.WORK_QUEUE_FLAG_HIGH_FREQ));

            /* Process nodes which have a start func */
            for (int i = 0; i < m_node_list.count(); i++)  //for_each(discrete_base_node **, node, &m_node_list)
            {
                discrete_base_node node = m_node_list[i];

                node.start();
            }

            /* Now set up tasks */
            for (int i = 0; i < task_list.count(); i++)  //for_each(discrete_task **, task, &task_list)
            {
                discrete_task task = task_list[i];

                for (int j = 0; j < task_list.count(); j++)  //for_each(discrete_task **, dest_task, &task_list)
                {
                    discrete_task dest_task = task_list[j];

                    if (task.task_group > dest_task.task_group)
                        dest_task.check(task);
                }
            }
        }

        protected override void device_stop()
        {
            if (m_queue != null)
            {
                osdcore_global.m_osdcore.osd_work_queue_free(m_queue);
            }

            if (m_profiling != 0)
            {
                display_profiling();
            }

            /* Process nodes which have a stop func */

            for (int i = 0; i < m_node_list.count(); i++)  //for_each(discrete_base_node **, node, &m_node_list)
            {
                discrete_base_node node = m_node_list[i];

                node.stop();
            }

            if (discrete_global.DISCRETE_DEBUGLOG != 0)
            {
                throw new emu_unimplemented();
#if false
                /* close the debug log */
                if (m_disclogfile)
                    fclose(m_disclogfile);
                m_disclogfile = NULL;
#endif
            }
        }

        //-------------------------------------------------
        //  device_reset - device-specific reset
        //-------------------------------------------------
        protected override void device_reset()
        {
            update_to_current_time();

            /* loop over all nodes */
            for (int i = 0; i < m_node_list.count(); i++)  //for_each (discrete_base_node **, node, &m_node_list)
            {
                discrete_base_node node = m_node_list[i];

                /* Fimxe : node_level */
                //node.m_output[0][0] = 0;

                node.reset();
            }
        }


        //-------------------------------------------------
        //  discrete_build_list: Build import list
        //-------------------------------------------------
        void discrete_build_list(discrete_block [] intf, ref vector_t<discrete_block> block_list)
        {
            int node_count = 0;

            for (; intf[node_count].type != (int)discrete_node_type.DSS_NULL; )
            {
                /* scan imported */
                if (intf[node_count].type == (int)discrete_node_type.DSO_IMPORT)
                {
                    discrete_log("discrete_build_list() - DISCRETE_IMPORT @ NODE_{0}", discrete_global.NODE_INDEX((NODE)intf[node_count].node));
                    discrete_build_list((discrete_block [])intf[node_count].custom, ref block_list);
                }
                else if (intf[node_count].type == (int)discrete_node_type.DSO_REPLACE)
                {
                    bool found = false;
                    node_count++;
                    if (intf[node_count].type == (int)discrete_node_type.DSS_NULL)
                        throw new emu_fatalerror("discrete_build_list: DISCRETE_REPLACE at end of node_list\n");

                    for (int i=0; i < block_list.count(); i++)
                    {
                        discrete_block block = block_list[i];

                        if (block.type != (int)discrete_global.NODE_SPECIAL)
                        {
                            if (block.node == intf[node_count].node)
                            {
                                block_list[i] = intf[node_count];
                                discrete_log("discrete_build_list() - DISCRETE_REPLACE @ NODE_{0}", discrete_global.NODE_INDEX((NODE)intf[node_count].node));
                                found = true;
                                break;
                            }
                        }
                    }

                    if (!found)
                        throw new emu_fatalerror("discrete_build_list: DISCRETE_REPLACE did not found node {0}\n", discrete_global.NODE_INDEX((NODE)intf[node_count].node));

                }
                else if (intf[node_count].type == (int)discrete_node_type.DSO_DELETE)
                {
                    vector_t<int> deletethem = new vector_t<int>();

                    for (int i=0; i<block_list.count(); i++)
                    {
                        discrete_block block = block_list[i];

                        if ((block.node >= intf[node_count].input_node[0]) &&
                                (block.node <= intf[node_count].input_node[1]))
                        {
                            discrete_log("discrete_build_list() - DISCRETE_DELETE deleted NODE_{0}", discrete_global.NODE_INDEX((NODE)block.node));
                            deletethem.add(i);
                        }
                    }

                    for (int i = 0; i < deletethem.count(); i++)  //for_each (int *, i, &deletethem)
                        block_list.remove(deletethem[i]);
                }
                else
                {
                    discrete_log("discrete_build_list() - adding node {0}\n", node_count);
                    block_list.add(intf[node_count]);
                }

                node_count++;
            }
        }

        //-------------------------------------------------
        // discrete_sanity_check: Sanity check list
        //-------------------------------------------------
        void discrete_sanity_check(vector_t<discrete_block> block_list)
        {
            int node_count = 0;

            discrete_log("discrete_start() - Doing node list sanity check");
            for (int i=0; i < block_list.count(); i++)
            {
                discrete_block block = block_list[i];

                /* make sure we don't have too many nodes overall */
                if (node_count > discrete_global.DISCRETE_MAX_NODES)
                    throw new emu_fatalerror("discrete_start() - Upper limit of {0} nodes exceeded, have you terminated the interface block?\n", discrete_global.DISCRETE_MAX_NODES);

                /* make sure the node number is in range */
                if (block.node < (int)discrete_global.NODE_START || block.node > (int)discrete_global.NODE_END)
                    throw new emu_fatalerror("discrete_start() - Invalid node number on node {0} descriptor\n", block.node);

                /* make sure the node type is valid */
                if (block.type > (int)discrete_node_type.DSO_OUTPUT)
                    throw new emu_fatalerror("discrete_start() - Invalid function type on NODE_{0}\n", discrete_global.NODE_INDEX((NODE)block.node));

                /* make sure this is a main node */
                if (discrete_global.NODE_CHILD_NODE_NUM((NODE)block.node) > 0)
                    throw new emu_fatalerror("discrete_start() - Child node number on NODE_{0}\n", discrete_global.NODE_INDEX((NODE)block.node));

                node_count++;
            }

            discrete_log("discrete_start() - Sanity check counted {0} nodes", node_count);
        }


        /*************************************
         *
         *  Master discrete system stop
         *
         *************************************/

        static UInt64 list_run_time(vector_t<discrete_base_node> list)
        {
            UInt64 total = 0;

            for (int i = 0; i < list.count(); i++)  //for_each(discrete_base_node **, node, &list)
            {
                discrete_base_node node = list[i];

                discrete_step_interface step;
                if (node.interface_get(out step))
                    total += step.run_time;
            }

            return total;
        }

        static UInt64 step_list_run_time(vector_t<discrete_step_interface> list)
        {
            UInt64 total = 0;

            for (int i = 0; i < list.count(); i++)  //for_each(discrete_step_interface **, node, &list)
            {
                discrete_step_interface node = list[i];

                total += node.run_time;
            }
            return total;
        }

        void display_profiling()
        {
            int count;
            UInt64 total;
            UInt64 tresh;
            double tt;

            /* calculate total time */
            total = list_run_time(m_node_list);
            count = m_node_list.count();
            /* print statistics */
            global.osd_printf_info("Total Samples  : {0}\n", m_total_samples);
            tresh = total / (UInt64)count;
            global.osd_printf_info("Threshold (mean): {0}\n", tresh / m_total_samples);
            for (int i = 0; i < m_node_list.count(); i++)  //for_each(discrete_base_node **, node, &m_node_list)
            {
                discrete_base_node node = m_node_list[i];

                discrete_step_interface step;
                if (node.interface_get(out step))
                    if (step.run_time > tresh)
                        global.osd_printf_info("{0}: {1} {2} {3}\n", node.index(), node.module_name(), (double)step.run_time / (double)total * 100.0, ((double)step.run_time) / (double)m_total_samples);
            }

            /* Task information */
            for (int i = 0; i < task_list.count(); i++)  //for_each(discrete_task **, task, &task_list)
            {
                discrete_task task = task_list[i];

                tt =  step_list_run_time(task.step_list);

                global.osd_printf_info("Task({0}): {1} {2}\n", task.task_group, tt / (double)total * 100.0, tt / (double)m_total_samples);
            }

            global.osd_printf_info("Average samples/double->update: {0}\n", (double)m_total_samples / (double)m_total_stream_updates);
        }

        /*************************************
         *
         *  First pass init of nodes
         *
         *************************************/
        void init_nodes(vector_t<discrete_block> block_list)
        {
            discrete_task task = null;
            /* list tail pointers */
            int has_tasks = 0;

            /* check whether we have tasks ... */
            if (discrete_global.USE_DISCRETE_TASKS != 0)
            {
                for (int i = 0; i < block_list.count(); i++)
                {
                    if (block_list[i].type == (int)discrete_node_type.DSO_TASK_START)
                        has_tasks = 1;
                }
            }

            if (has_tasks == 0)
            {
                /* make sure we have one simple task
                 * No need to create a node since there are no dependencies.
                 */
                task = new discrete_task(this);  // auto_alloc_clear(machine(), discrete_task(*this));
                task_list.add(task);
            }

            /* loop over all nodes */
            for (int i = 0; i < block_list.count(); i++)
            {
                discrete_block block = block_list[i];

                //discrete_base_node *node = block->factory->Create(this, block);
                discrete_base_node node = block.factory(this, block);
                /* keep track of special nodes */
                if (block.node == (int)discrete_global.NODE_SPECIAL)
                {
                    switch (block.type)
                    {
                        /* Output Node */
                        case (int)discrete_node_type.DSO_OUTPUT:
                            /* nothing -> handled later */
                            break;

                        /* CSVlog Node for debugging */
                        case (int)discrete_node_type.DSO_CSVLOG:
                            break;

                        /* Wavelog Node for debugging */
                        case (int)discrete_node_type.DSO_WAVLOG:
                            break;

                        /* Task processing */
                        case (int)discrete_node_type.DSO_TASK_START:
                            if (discrete_global.USE_DISCRETE_TASKS != 0)
                            {
                                if (task != null)
                                    throw new emu_fatalerror("init_nodes() - Nested DISCRETE_START_TASK.\n");

                                task = new discrete_task(this);  // auto_alloc_clear(machine(), discrete_task(*this));
                                task.task_group = (int)block.initial[0];
                                if (task.task_group < 0 || task.task_group >= discrete_global.DISCRETE_MAX_TASK_GROUPS)
                                    throw new emu_fatalerror("discrete_dso_task: illegal task_group {0}\n", task.task_group);

                                //printf("task group %d\n", task->task_group);
                                task_list.add(task);
                            }
                            break;

                        case (int)discrete_node_type.DSO_TASK_END:
                            if (discrete_global.USE_DISCRETE_TASKS != 0)
                            {
                                if (task == null)
                                    throw new emu_fatalerror("init_nodes() - NO DISCRETE_START_TASK.\n");
                            }
                            break;

                        default:
                            throw new emu_fatalerror("init_nodes() - Failed, trying to create unknown special discrete node.\n");
                    }
                }

                /* otherwise, make sure we are not a duplicate, and put ourselves into the indexed list */
                else
                {
                    if (m_indexed_node[discrete_global.NODE_INDEX((NODE)block.node)] != null)
                        throw new emu_fatalerror("init_nodes() - Duplicate entries for NODE_{0}\n", discrete_global.NODE_INDEX((NODE)block.node));

                    m_indexed_node[discrete_global.NODE_INDEX((NODE)block.node)] = node;
                }

                /* add to node list */
                m_node_list.add(node);

                /* our running order just follows the order specified */
                /* does the node step ? */
                discrete_step_interface step;
                if (node.interface_get(out step))
                {
                    /* do we belong to a task? */
                    if (task == null)
                        throw new emu_fatalerror("init_nodes() - found node outside of task: {0}\n", node.module_name());
                    else
                        task.step_list.add(step);
                }

                if (discrete_global.USE_DISCRETE_TASKS != 0 && block.type == (int)discrete_node_type.DSO_TASK_END)
                {
                    task = null;
                }

                /* and register save state */
                node.save_state();
            }

            if (has_tasks == 0)
            {
            }
        }
    }


    public class device_sound_interface_discrete : device_sound_interface
    {
        public device_sound_interface_discrete(machine_config mconfig, device_t device) : base(mconfig, device) { }


        // device_sound_interface overrides

        //-------------------------------------------------
        //  sound_stream_update - handle update requests for
        //  our sound stream
        //-------------------------------------------------
        public override void sound_stream_update(sound_stream stream, ListPointer<stream_sample_t> [] inputs, ListPointer<stream_sample_t> [] outputs, int samples)
        {
            discrete_sound_device discrete_sound = (discrete_sound_device)device();

            int outputnum = 0;

            if (samples == 0)
                return;

            /* Setup any output streams */
            for (int i = 0; i < discrete_sound.m_output_list.count(); i++)  //for_each(discrete_sound_output_interface **, node, &m_output_list)
            {
                discrete_sound_output_interface node = discrete_sound.m_output_list[i];

                node.set_output_ptr(new ListPointer<stream_sample_t>(outputs[outputnum]));
                outputnum++;
            }

            /* Setup any input streams */
            for (int i = 0; i < discrete_sound.m_input_stream_list.count(); i++)  //for_each(discrete_dss_input_stream_node **, node, &m_input_stream_list)
            {
                discrete_dss_input_stream_node node = discrete_sound.m_input_stream_list[i];

                node.m_ptr = new ListPointer<stream_sample_t>(inputs[node.m_stream_in_number]);
            }

            /* just process it */
            discrete_sound.process(samples);
        }
    }


    // ======================> discrete_sound_device
    class discrete_sound_device : discrete_device
                                  //  public device_sound_interface
    {
        //DEFINE_DEVICE_TYPE(DISCRETE, discrete_sound_device, "discrete", "Discrete Sound")
        static device_t device_creator_discrete_sound_device(device_type type, machine_config mconfig, string tag, device_t owner, u32 clock) { return new discrete_sound_device(mconfig, tag, owner, clock); }
        public static readonly device_type DISCRETE = DEFINE_DEVICE_TYPE(device_creator_discrete_sound_device, "discrete", "Discrete Sound");


        /* the output stream */
        sound_stream m_stream;

        /* the input streams */
        public vector_t<discrete_dss_input_stream_node> m_input_stream_list = new vector_t<discrete_dss_input_stream_node>();
        /* output node tracking */
        public vector_t<discrete_sound_output_interface> m_output_list = new vector_t<discrete_sound_output_interface>();


        // construction/destruction
        //discrete_sound_device(machine_config mconfig, string tag, device_t owner, uint32_t clock, discrete_block [] intf)
        //    : this(mconfig, tag, owner, clock)
        public void discrete_sound_device_after_ctor(discrete_block [] intf)  // call this after _ADD() because can't figure out how to port the crazy device_add_impl
        {
            set_intf(intf);
        }

        //discrete_sound_device(machine_config mconfig, string tag, device_t owner, discrete_block [] intf)
        //    : this(mconfig, tag, owner, 0)
        //{
        //    set_intf(intf);
        //}

        discrete_sound_device(machine_config mconfig, string tag, device_t owner, uint32_t clock = 0)
            : base(mconfig, DISCRETE, tag, owner, clock)
        {
            m_class_interfaces.Add(new device_sound_interface_discrete(mconfig, this));  //device_sound_interface(mconfig, *this)

            m_stream = null;
        }


        /* --------------------------------- */

        public override void update_to_current_time() { m_stream.update(); }

        public sound_stream get_stream() { return m_stream; }


        // device-level overrides
        //-------------------------------------------------
        //  device_start - device-specific startup
        //-------------------------------------------------
        protected override void device_start()
        {
            m_input_stream_list.clear();
            m_output_list.clear();

            /* call the parent */
            base.device_start();

            /* look for input stream nodes */
            for (int i = 0; i < m_node_list.count(); i++)  //for_each(discrete_base_node **, node, &m_node_list)
            {
                discrete_base_node node = m_node_list[i];

                /* if we are an stream input node, track that */
                discrete_dss_input_stream_node input_stream = (node is discrete_dss_input_stream_node) ? (discrete_dss_input_stream_node)node : null;
                if (input_stream != null)
                {
                    m_input_stream_list.add(input_stream);
                }

                /* if this is an output interface, add it the output list */
                discrete_sound_output_interface out_intf;
                if (node.interface_get(out out_intf))
                    m_output_list.add(out_intf);
            }

            /* if no outputs, give an error */
            if (m_output_list.count() == 0)
                throw new emu_fatalerror("init_nodes() - Couldn't find an output node\n");

            /* initialize the stream(s) */
            m_stream = machine().sound().stream_alloc(this, m_input_stream_list.count(), m_output_list.count(), m_sample_rate);

            /* Finalize stream_input_nodes */
            for (int i = 0; i < m_input_stream_list.count(); i++)  //for_each(discrete_dss_input_stream_node **, node, &m_input_stream_list)
            {
                discrete_dss_input_stream_node node = m_input_stream_list[i];

                node.stream_start();
            }
        }

        protected override void device_reset()
        {
            base.device_reset();
        }


        // device_sound_interface overrides
        //virtual void sound_stream_update(sound_stream &stream, stream_sample_t **inputs, stream_sample_t **outputs, int samples);
    }


    /*************************************
     *
     *  Node class
     *
     *************************************/
    public class discrete_base_node
    {
        public double DSS_INPUT__GAIN { get { return DISCRETE_INPUT(0); } }
        public double DSS_INPUT__OFFSET { get { return DISCRETE_INPUT(1); } }
        public double DSS_INPUT__INIT { get { return DISCRETE_INPUT(2); } }


        /* calculate charge exponent using discrete sample time */
        public double RC_CHARGE_EXP(double rc) { return 1.0 - Math.Exp(-sample_time() / (rc)); }


        //#define DISCRETE_INPUT(_num)                  (*(this->m_input[_num]))
        //#define DISCRETE_INPUT(_num)                    (input(_num))
        public double DISCRETE_INPUT(int num) { return input(num); }


        public ListPointer<double> [] m_output = new ListPointer<double> [discrete_global.DISCRETE_MAX_OUTPUTS];  //double                          m_output[DISCRETE_MAX_OUTPUTS];     /* The node's last output value */
        public ListPointer<double> [] m_input = new ListPointer<double> [discrete_global.DISCRETE_MAX_INPUTS];  //const double *                  m_input[DISCRETE_MAX_INPUTS];       /* Addresses of Input values */
        protected discrete_device m_device;                           /* Points to the parent */


        discrete_block m_block;  //const discrete_block *  m_block;                            /* Points to the node's setup block. */
        int m_active_inputs;                    /* Number of active inputs on this node type */

        Object m_custom;  //const void *                    m_custom;                           /* Custom function specific initialisation data */
        int m_input_is_node;

        discrete_step_interface m_step_intf;
        discrete_input_interface m_input_intf;
        discrete_sound_output_interface m_output_intf;


        //friend class discrete_device;
        //template <class C> friend class discrete_node_factory;
        //friend class discrete_task;


        public discrete_base_node()
        {
            m_device = null;
            m_block = null;
            m_active_inputs = 0;
            m_custom = null;
            m_input_is_node = 0;
            m_step_intf = null;
            m_input_intf = null;
            m_output_intf = null;


            //m_output[0][0] = 0.0;


            for (int i = 0; i < discrete_global.DISCRETE_MAX_OUTPUTS; i++)
            {
                m_output[i] = new ListPointer<double>(new std_vector<double>(1));
                m_input[i] = new ListPointer<double>(new std_vector<double>(1));
            }
        }

        ~discrete_base_node() { }


        public virtual void reset() { }
        public virtual void start() { }
        public virtual void stop() { }

        public virtual void save_state()
        {
            if (m_block.node != (int)discrete_global.NODE_SPECIAL)
                m_device.save_item(m_output, "m_output", m_block.node);
        }

        protected virtual int max_output() { return 1; }


        public bool interface_get(out discrete_step_interface intf) { intf = m_step_intf; return intf != null; }  //inline bool interface(discrete_step_interface *&intf) const { intf = m_step_intf; return (intf != NULL); }
        public bool interface_get(out discrete_input_interface intf) { intf = m_input_intf; return intf != null; }  //inline bool interface(discrete_input_interface *&intf) const { intf = m_input_intf; return (intf != NULL); }
        public bool interface_get(out discrete_sound_output_interface intf) { intf = m_output_intf; return intf != null; }  //inline bool interface(discrete_sound_output_interface *&intf) const { intf = m_output_intf; return (intf != NULL); }


        /* get the input value from node #n */
        double input(int n) { return m_input[n][0]; }

        /* set an output */
        public void set_output(int n, double val) { if (m_output[n].Buffer != null) m_output[n][0] = val; }

        /* Return the node index, i.e. X from NODE(X) */
        public int index() { return discrete_global.NODE_INDEX((NODE)m_block.node); }

        /* Return the node number, i.e. NODE(X) */
        public int block_node() { return m_block.node;  }

        /* Custom function specific initialisation data */
        protected Object custom_data() { return m_custom; }

        public int input_node(int inputnum) { return m_block.input_node[inputnum]; }

        /* Number of active inputs on this node type */
        public int active_inputs() { return m_active_inputs; }
        /* Bit Flags.  1 in bit location means input_is_node */
        protected int input_is_node() { return m_input_is_node; }

        double sample_time() { return m_device.sample_time(); }
        public int sample_rate() { return m_device.sample_rate(); }

        public string module_name() { return m_block.mod_name; }
        //inline int          module_type(void) const { return m_block->type; }


        /* finish node setup after allocation is complete */
        public void init(discrete_device pdev, discrete_block xblock)
        {
            m_device = pdev;
            m_block = xblock;

            m_custom = m_block.custom;
            m_active_inputs = m_block.active_inputs;

            m_step_intf = (this is discrete_step_interface) ? (discrete_step_interface)this : null;
            m_input_intf = (this is discrete_input_interface) ? (discrete_input_interface)this : null;
            m_output_intf = (this is discrete_sound_output_interface) ? (discrete_sound_output_interface)this : null;

            if (m_step_intf != null)
            {
                m_step_intf.run_time = 0;
                m_step_intf.self = this;
            }
        }


        public void resolve_input_nodes()
        {
            int inputnum;

            /* loop over all active inputs */
            for (inputnum = 0; inputnum < m_active_inputs; inputnum++)
            {
                int inputnode = m_block.input_node[inputnum];

                /* if this input is node-based, find the node in the indexed list */
                if (discrete_global.IS_VALUE_A_NODE(inputnode))
                {
                    //discrete_base_node *node_ref = m_device->m_indexed_node[NODE_INDEX(inputnode)];
                    discrete_base_node node_ref = m_device.discrete_find_node(inputnode);
                    if (node_ref == null)
                        throw new emu_fatalerror("discrete_start - NODE_{0} referenced a non existent node NODE_{1}\n", index(), discrete_global.NODE_INDEX((NODE)inputnode));

                    if ((discrete_global.NODE_CHILD_NODE_NUM((NODE)inputnode) >= node_ref.max_output()) /*&& (node_ref->module_type() != DST_CUSTOM)*/)
                        throw new emu_fatalerror("discrete_start - NODE_{0} referenced non existent output {1} on node NODE_{2}\n", index(), discrete_global.NODE_CHILD_NODE_NUM((NODE)inputnode), discrete_global.NODE_INDEX((NODE)inputnode));

                    m_input[inputnum] = new ListPointer<double>(node_ref.m_output[discrete_global.NODE_CHILD_NODE_NUM((NODE)inputnode)]);  /* Link referenced node out to input */
                    m_input_is_node |= 1 << inputnum;           /* Bit flag if input is node */
                }
                else
                {
                    /* warn if trying to use a node for an input that can only be static */
                    if (discrete_global.IS_VALUE_A_NODE((int)m_block.initial[inputnum]))
                    {
                        m_device.discrete_log("Warning - discrete_start - NODE_{0} trying to use a node on static input {1}", index(), inputnum);
                        /* also report it in the error log so it is not missed */
                        m_device.logerror("Warning - discrete_start - NODE_{0} trying to use a node on static input {1}", index(), inputnum);
                    }
                    else
                    {
                        m_input[inputnum] = new ListPointer<double>(m_block.initial, inputnum);
                    }
                }
            }

            for (inputnum = m_active_inputs; inputnum < discrete_global.DISCRETE_MAX_INPUTS; inputnum++)
            {
                /* FIXME: Check that no nodes follow ! */
                m_input[inputnum] = new ListPointer<double>(m_block.initial, inputnum);
            }
        }
    }


    class discrete_node_factory<class_type> where class_type : discrete_base_node, new()
    {
        public discrete_base_node Create(discrete_device pdev, discrete_block block)
        {
            discrete_base_node r = new class_type();  // auto_alloc_clear(pdev->machine(), C);

            r.init(pdev, block);
            return r;
        }
    }


    class output_buffer
    {
        public ListBase<double> node_buf;  //double                      *node_buf;
        public ListPointer<double> source;  //const double                *source;
        public ListPointer<double> ptr;  //volatile double             *ptr;
        public int node_num;
    }


    class input_buffer
    {
        public ListPointer<double> ptr;  //volatile const double       *ptr;               /* pointer into linked_outbuf.nodebuf */
        public output_buffer linked_outbuf;  //output_buffer *             linked_outbuf;      /* what output are we connected to ? */
        public ListPointer<double> buffer;  //double                      buffer;             /* input[] will point here */
    }


    class discrete_task
    {
        //friend class discrete_device;


        //const linked_list_entry *list;
        public vector_t<discrete_step_interface> step_list = new vector_t<discrete_step_interface>();

        /* list of source nodes */
        vector_t<input_buffer> source_list = new vector_t<input_buffer>();      /* discrete_source_node */

        public int task_group;


        vector_t<output_buffer> m_buffers = new vector_t<output_buffer>();
        discrete_device m_device;

        int m_threadid;  //volatile INT32          m_threadid;
        int m_samples;  //volatile int            m_samples;


        public discrete_task(discrete_device pdev)
        {
            task_group = 0;
            m_device = pdev;
            m_threadid = -1;
            m_samples = 0;


            source_list.clear();
            step_list.clear();
            m_buffers.clear();
        }
        ~discrete_task() { }


        /*************************************
         *
         *  Task implementation
         *
         *************************************/

        void step_nodes()
        {
            for (int i = 0; i < source_list.count(); i++)  //for_each(input_buffer *, sn, &source_list)
            {
                input_buffer sn = source_list[i];

                sn.buffer = new ListPointer<double>(sn.ptr);  //sn.buffer = *sn.ptr++;
                sn.ptr++;
            }

            if (m_device.profiling() == 0)
            {
                for (int i = 0; i < step_list.count(); i++)  //for_each(discrete_step_interface **, entry, &step_list)
                {
                    discrete_step_interface entry = step_list[i];

                    /* Now step the node */
                    entry.step();
                }
            }
            else
            {
                osd_ticks_t last = (osd_ticks_t)eminline_global.get_profile_ticks();

                for (int i = 0; i < step_list.count(); i++)  //for_each(discrete_step_interface **, entry, &step_list)
                {
                    discrete_step_interface entry = step_list[i];

                    discrete_step_interface node = entry;

                    node.run_time -= last;
                    node.step();
                    last = (osd_ticks_t)eminline_global.get_profile_ticks();
                    node.run_time += last;
                }
            }

            /* buffer the outputs */
            for (int i = 0; i < m_buffers.count(); i++)  //for_each(output_buffer *, outbuf, &m_buffers)
            {
                output_buffer outbuf = m_buffers[i];

                outbuf.ptr = new ListPointer<double>(outbuf.source);  //*(outbuf.ptr++) = *outbuf.source;
                outbuf.ptr++;
            }
        }

        bool lock_threadid(int32_t threadid)
        {
            throw new emu_unimplemented();
            // OLD
            //int prev_id;
            //prev_id = eminline_global.compare_exchange32(ref m_threadid, -1, threadid);
                                        //public static int compare_exchange32(ref int ptr, int compare, int exchange)
                                        //{
                                        //    int oldval = ptr;
                                        //    if (ptr == compare)
                                        //        ptr = exchange;
                                        //    return oldval;
                                        //}
            //return prev_id == -1 && m_threadid == threadid;
            // NEW
            //int expected = -1;
            //return m_threadid.compare_exchange_weak(expected, threadid, std::memory_order_release,std::memory_order_relaxed);
        }

        public void unlock() { m_threadid = -1; }


        public static Object task_callback(Object param, int threadid)
        {
            vector_t<discrete_task> list = (vector_t<discrete_task>)param;

            do
            {
                for (int i = 0; i < list.count(); i++)  //for_each(discrete_task **, task, list)
                {
                    discrete_task task = list[i];

                    /* try to lock */
                    if (task.lock_threadid(threadid))
                    {
                        if (!task.process())
                            return null;

                        task.unlock();
                    }
                }
            } while (true);

            return null;
        }


        bool process()
        {
            int samples = Math.Min(m_samples, discrete_global.MAX_SAMPLES_PER_TASK_SLICE);

            /* check dependencies */
            for (int i = 0; i < source_list.count(); i++)  //for_each(input_buffer *, sn, &source_list)
            {
                input_buffer sn = source_list[i];

                int avail;

                // make sure buffer pointers are equal, so we can perform math operation on the offsets
                global.assert(sn.linked_outbuf.ptr.Buffer == sn.ptr.Buffer);

                avail = sn.linked_outbuf.ptr.Offset - sn.ptr.Offset;  // avail = sn.linked_outbuf.ptr - sn.ptr;

                global.assert_always(avail >= 0, "task_callback: available samples are negative");

                if (avail < samples)
                    samples = avail;
            }

            m_samples -= samples;

            global.assert_always(m_samples >=0, "task_callback: task_samples got negative");

            while (samples > 0)
            {
                /* step */
                step_nodes();
                samples--;
            }

            if (m_samples == 0)
            {
                /* return and keep the task locked so it is not picked up by other worker threads */
                return false;
            }

            return true;
        }


        public void check(discrete_task dest_task)
        {
            int inputnum;

            /* Determine, which nodes in the task are referenced by nodes in dest_task
             * and add them to the list of nodes to be buffered for further processing
             */
            for (int i1 = 0; i1 < step_list.count(); i1++)  //for_each(discrete_step_interface **, node_entry, &step_list)
            {
                discrete_step_interface node_entry = step_list[i1];

                discrete_base_node task_node = node_entry.self;

                for (int j1 = 0; j1 < dest_task.step_list.count(); j1++)  //for_each(discrete_step_interface **, step_entry, &dest_task->step_list)
                {
                    discrete_step_interface step_entry = dest_task.step_list[j1];

                    discrete_base_node dest_node = step_entry.self;

                    /* loop over all active inputs */
                    for (inputnum = 0; inputnum < dest_node.active_inputs(); inputnum++)
                    {
                        int inputnode_num = dest_node.input_node(inputnum);
                        if (discrete_global.IS_VALUE_A_NODE(inputnode_num))
                        {
                            /* Fixme: sub nodes ! */
                            if (discrete_global.NODE_DEFAULT_NODE((NODE)task_node.block_node()) == discrete_global.NODE_DEFAULT_NODE((NODE)inputnode_num))
                            {
                                input_buffer source = new input_buffer();
                                int i;
                                int found = -1;
                                output_buffer pbuf = null;

                                for (i = 0; i < m_buffers.count(); i++)
                                {
                                    //if (m_buffers[i].node->block_node() == inputnode_num)
                                    if (m_buffers[i].node_num == inputnode_num)
                                    {
                                        found = i;
                                        pbuf = m_buffers[i];
                                        break;
                                    }
                                }

                                if (found < 0)
                                {
                                    output_buffer buf = new output_buffer();

                                    buf.node_buf = global.auto_alloc_array<double>(m_device.machine(), (UInt32)((task_node.sample_rate() + sound_manager.STREAMS_UPDATE_FREQUENCY) / sound_manager.STREAMS_UPDATE_FREQUENCY));
                                    buf.ptr = new ListPointer<double>(buf.node_buf);
                                    buf.source = new ListPointer<double>(dest_node.m_input[inputnum]);
                                    buf.node_num = inputnode_num;
                                    //buf.node = device->discrete_find_node(inputnode);
                                    m_buffers.count();
                                    pbuf = m_buffers.add(buf);
                                }

                                m_device.discrete_log("dso_task_start - buffering {0}({1}) in task {2} group {3} referenced by {4} group {5}", discrete_global.NODE_INDEX((NODE)inputnode_num), discrete_global.NODE_CHILD_NODE_NUM((NODE)inputnode_num), this, task_group, dest_node.index(), dest_task.task_group);

                                /* register into source list */
                                //source = auto_alloc(device->machine(), discrete_source_node);
                                //source.task = this;
                                //source.output_node = i;
                                source.linked_outbuf = pbuf;
                                source.buffer = new ListPointer<double>();  /* please compiler */
                                source.ptr = null;
                                dest_task.source_list.add(source);

                                /* point the input to a buffered location */
                                dest_node.m_input[inputnum] = new ListPointer<double>(dest_task.source_list[dest_task.source_list.count() - 1].buffer); // was copied!   &source.buffer;
                            }
                        }
                    }
                }
            }
        }

        public void prepare_for_queue(int samples)
        {
            m_samples = samples;

            /* set up task buffers */
            for (int i = 0; i < m_buffers.count(); i++)  //for_each(output_buffer *, ob, &m_buffers)
            {
                output_buffer ob = m_buffers[i];

                ob.ptr = new ListPointer<double>(ob.node_buf);
            }

            /* initialize sources */
            for (int i = 0; i < source_list.count(); i++)  //for_each(input_buffer *, sn, &source_list)
            {
                input_buffer sn = source_list[i];

                sn.ptr = new ListPointer<double>(sn.linked_outbuf.node_buf);
            }
        }
    }
}
